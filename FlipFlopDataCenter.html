<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tutorial FLIP FLOP D - Administraci√≥n de Centros de Datos | Quartus II & Altera Max II</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f3460 0%, #0f4c75 25%, #3282b8 75%, #bbe1fa 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .presentation-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            padding: 12px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            min-height: 70px;
            position: relative;
            z-index: 1000;
            border-bottom: 2px solid rgba(34, 197, 94, 0.3);
        }

        .header-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .datacenter-logo {
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            flex-shrink: 0;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
        }

        .course-info h1 {
            font-size: 1.3rem;
            color: #22c55e;
            margin-bottom: 4px;
            font-weight: 700;
        }

        .course-info p {
            font-size: 0.75rem;
            opacity: 0.9;
            line-height: 1.3;
            color: #bbe1fa;
        }

        .nav-btn-header {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
            min-width: 50px;
            min-height: 45px;
            box-shadow: 0 3px 10px rgba(34, 197, 94, 0.3);
        }

        .nav-btn-header:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5);
            background: linear-gradient(135deg, #16a34a, #22c55e);
        }

        .nav-btn-header:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .slide-counter {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid rgba(34, 197, 94, 0.4);
            padding: 6px 14px;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 600;
            white-space: nowrap;
            color: #22c55e;
        }

        .navigation-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slide-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 35px;
            overflow: visible;
            position: relative;
        }

        .slide {
            max-width: 1300px;
            width: 100%;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(25px);
            border-radius: 25px;
            padding: 45px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            text-align: center;
            display: none;
            min-height: 65vh;
            overflow-y: auto;
            margin: 15px;
            border: 2px solid rgba(34, 197, 94, 0.2);
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        .slide h1 {
            font-size: 2.8rem;
            margin-bottom: 35px;
            background: linear-gradient(45deg, #22c55e, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: #22c55e;
            font-weight: 800;
        }

        .slide h2 {
            font-size: 2.2rem;
            margin-bottom: 30px;
            color: #22c55e;
            font-weight: 700;
        }

        .slide h3 {
            font-size: 1.6rem;
            margin-bottom: 25px;
            color: #bbe1fa;
            font-weight: 600;
        }

        .slide p {
            font-size: 1.15rem;
            line-height: 1.7;
            margin-bottom: 22px;
            color: #f0f8ff;
        }

        .slide ul {
            text-align: left;
            max-width: 900px;
            margin: 0 auto 25px;
        }

        .slide li {
            font-size: 1.1rem;
            margin-bottom: 16px;
            margin-left: 25px;
            color: #f0f8ff;
        }

        /* Tarjetas especializadas para contexto de data center */
        .datacenter-objective {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(59, 130, 246, 0.25));
            border: 3px solid rgba(34, 197, 94, 0.6);
            border-radius: 20px;
            padding: 25px;
            margin: 20px 0;
            position: relative;
        }

        .datacenter-objective::before {
            content: "üè¢";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #22c55e;
            color: white;
            padding: 8px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .availability-card {
            background: rgba(59, 130, 246, 0.25);
            border: 3px solid rgba(59, 130, 246, 0.6);
            border-radius: 20px;
            padding: 25px;
            margin: 20px 0;
            position: relative;
        }

        .availability-card::before {
            content: "üñ•Ô∏è";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #3b82f6;
            color: white;
            padding: 8px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .sla-card {
            background: rgba(168, 85, 247, 0.25);
            border: 3px solid rgba(168, 85, 247, 0.6);
            border-radius: 20px;
            padding: 25px;
            margin: 20px 0;
            position: relative;
        }

        .sla-card::before {
            content: "üìä";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #a855f7;
            color: white;
            padding: 8px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .monitoring-card {
            background: rgba(249, 115, 22, 0.25);
            border: 3px solid rgba(249, 115, 22, 0.6);
            border-radius: 20px;
            padding: 25px;
            margin: 20px 0;
            position: relative;
        }

        .monitoring-card::before {
            content: "üìà";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #f97316;
            color: white;
            padding: 8px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .infrastructure-block {
            background: linear-gradient(135deg, #22c55e, #3b82f6);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 20px;
            padding: 25px;
            margin: 25px 0;
            position: relative;
            box-shadow: 0 10px 30px rgba(34, 197, 94, 0.3);
        }

        .infrastructure-block::before {
            content: "üåê";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #22c55e;
            color: white;
            padding: 8px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .steps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin: 25px 0;
        }

        .step-card {
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(34, 197, 94, 0.4);
            border-radius: 20px;
            padding: 30px;
            transition: all 0.3s ease;
            position: relative;
        }

        .step-card:hover {
            transform: translateY(-8px);
            border-color: #22c55e;
            box-shadow: 0 15px 35px rgba(34, 197, 94, 0.3);
        }

        .step-number {
            position: absolute;
            top: -20px;
            left: 25px;
            background: #22c55e;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.3rem;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
        }

        .step-card h4 {
            color: #22c55e;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 700;
        }

        /* Bloques de c√≥digo mejorados para contexto IT */
        .code-block-container {
            position: relative;
            margin: 25px 0;
        }

        .code-block {
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            border: 3px solid rgba(34, 197, 94, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 0;
            font-family: 'Fira Code', 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
            overflow-x: auto;
            font-size: 0.95rem;
            line-height: 1.6;
            text-align: left;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            color: #e8e8e8;
            user-select: text;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .copy-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(34, 197, 94, 0.9);
            color: #1e1e1e;
            border: none;
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .copy-btn:hover {
            background: rgba(34, 197, 94, 1);
            transform: scale(1.05);
        }

        .language-label {
            position: absolute;
            top: -10px;
            left: 20px;
            background: rgba(34, 197, 94, 0.95);
            color: #1e1e1e;
            padding: 6px 15px;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        /* Syntax highlighting */
        .comment { color: #6A9955; font-style: italic; }
        .keyword { color: #569CD6; font-weight: bold; }
        .string { color: #CE9178; }
        .number { color: #B5CEA8; }
        .function { color: #DCDCAA; }
        .variable { color: #9CDCFE; }
        .operator { color: #D4D4D4; }

        .tab-container {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tab-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(34, 197, 94, 0.4);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .tab-button.active {
            background: rgba(34, 197, 94, 0.4);
            border-color: #22c55e;
            color: #22c55e;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .progress-indicator {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: rgba(255, 255, 255, 0.2);
            z-index: 9999;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #3b82f6);
            transition: width 0.4s ease;
            max-width: 100%;
        }

        .datacenter-metrics {
            background: rgba(168, 85, 247, 0.25);
            border: 3px solid rgba(168, 85, 247, 0.6);
            border-radius: 20px;
            padding: 25px;
            margin: 25px 0;
            position: relative;
        }

        .datacenter-metrics::before {
            content: "üìä";
            position: absolute;
            top: -15px;
            left: 25px;
            background: #a855f7;
            color: white;
            padding: 8px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .pin-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            overflow: hidden;
            font-size: 0.9rem;
        }

        .pin-table th,
        .pin-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid rgba(34, 197, 94, 0.3);
        }

        .pin-table th {
            background: rgba(34, 197, 94, 0.4);
            color: #22c55e;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 10px;
                text-align: center;
                padding: 8px 15px;
            }

            .slide {
                padding: 25px 15px;
                min-height: 55vh;
                margin: 8px;
            }

            .slide h1 {
                font-size: 2rem;
                margin-bottom: 25px;
            }

            .slide h2 {
                font-size: 1.6rem;
                margin-bottom: 20px;
            }

            .steps-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .nav-btn-header {
                padding: 10px 15px;
                font-size: 0.75rem;
            }

            .code-block {
                font-size: 0.85rem;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="presentation-container">
        <div class="header">
            <div class="header-group">
                <div class="datacenter-logo" aria-label="Data Center">üè¢</div>
                <div class="course-info">
                    <h1>FLIP FLOP D - ADMINISTRACI√ìN DE CENTROS DE DATOS</h1>
                    <p>Sistemas Digitales | Alta Disponibilidad y Failover | Quartus II v13.1</p>
                    <p>Proyecto Especializado: Sistema de Failover Autom√°tico en Data Center</p>
                </div>
            </div>
            <div class="header-group">
                <div class="navigation-controls">
                    <button class="nav-btn-header" id="prevBtn" onclick="navigateSlide(-1)">‚¨ÖÔ∏è Anterior</button>
                    <div class="slide-counter">
                        <span id="currentSlide">1</span>/<span id="totalSlides">6</span>
                    </div>
                    <button class="nav-btn-header" id="nextBtn" onclick="navigateSlide(1)">Siguiente ‚û°Ô∏è</button>
                </div>
            </div>
        </div>

        <div class="slide-container">
            <!-- Slide 1: Alta Disponibilidad en Centros de Datos -->
            <div class="slide active">
                <h1>üè¢ ALTA DISPONIBILIDAD EN CENTROS DE DATOS</h1>
                <h2>FLIP FLOP D para Sistemas de Failover Autom√°tico</h2>

                <div class="datacenter-objective">
                    <h3>üéØ Objetivo del Proyecto IT</h3>
                    <p>Implementar un <strong>FLIP FLOP D con Clock Enable</strong> como controlador de redundancia para <strong>failover autom√°tico</strong> de servidores cr√≠ticos en centro de datos, garantizando <strong>99.99% disponibilidad</strong> y cumplimiento de SLAs empresariales.</p>
                </div>

                <div class="availability-card">
                    <h3>üñ•Ô∏è Escenario Real: Sistema de Failover en Data Center</h3>
                    <p><strong>Aplicaci√≥n Pr√°ctica en Infraestructura Cr√≠tica</strong></p>
                    
                    <div class="infrastructure-block">
                        <h3>üåê Funci√≥n del FLIP FLOP D en la Infraestructura</h3>
                        <ul>
                            <li><strong>üñ•Ô∏è Memoria de estado servidor:</strong> Almacena si servidor est√° ACTIVO (Q=1) o STANDBY (Q=0)</li>
                            <li><strong>‚è∞ Sincronizaci√≥n cluster:</strong> Se actualiza con heartbeat del cluster manager</li>
                            <li><strong>üõ°Ô∏è Control disponibilidad:</strong> Enable gestiona switchover durante mantenimiento</li>
                            <li><strong>üìä Monitoreo SNMP:</strong> Salidas integradas con Nagios, Zabbix, Prometheus</li>
                        </ul>
                    </div>
                </div>

                <div class="monitoring-card">
                    <h3>üìà Casos de Uso en Data Centers</h3>
                    <div class="steps-grid">
                        <div class="step-card">
                            <div class="step-number">1</div>
                            <h4>SERVIDOR PRIMARIO ACTIVO</h4>
                            <p>D=1, CLK‚Üë ‚Üí Q=1</p>
                            <p>Servidor manejando tr√°fico productivo, DNS apuntando a IP primaria</p>
                        </div>
                        
                        <div class="step-card">
                            <div class="step-number">2</div>
                            <h4>SERVIDOR EN STANDBY</h4>
                            <p>D=0, CLK‚Üë ‚Üí Q=0</p>
                            <p>Servidor secundario listo, sincronizaci√≥n de datos activa</p>
                        </div>
                        
                        <div class="step-card">
                            <div class="step-number">3</div>
                            <h4>MAINTENANCE WINDOW</h4>
                            <p>ENABLE=0</p>
                            <p>Bloqueo de switchover durante actualizaciones programadas</p>
                        </div>
                        
                        <div class="step-card">
                            <div class="step-number">4</div>
                            <h4>FAILOVER AUTOM√ÅTICO</h4>
                            <p>RESET=1</p>
                            <p>Switchover inmediato por falla de conectividad/hardware</p>
                        </div>
                    </div>
                </div>

                <div class="datacenter-metrics">
                    <h3>üìä M√©tricas de Disponibilidad IT</h3>
                    <ul>
                        <li><strong>üéØ Uptime SLA:</strong> 99.99% disponibilidad anual (52.6 min downtime m√°ximo)</li>
                        <li><strong>‚è±Ô∏è MTTR:</strong> <5 minutos para switchover autom√°tico</li>
                        <li><strong>üîÑ RTO/RPO:</strong> Recovery objectives <1 minuto datos cr√≠ticos</li>
                        <li><strong>‚ö° Consumo energ√©tico:</strong> PUE <1.4 para eficiencia verde</li>
                        <li><strong>üí∞ Costo downtime:</strong> Evitar $100K/hora p√©rdidas por indisponibilidad</li>
                        <li><strong>üìà Escalabilidad:</strong> Soporte 1000+ servidores por cluster</li>
                    </ul>
                </div>

                <div class="sla-card">
                    <h3>üîß Integraci√≥n con Infraestructura IT</h3>
                    <ul>
                        <li><strong>Load Balancers:</strong> F5 BigIP, HAProxy, NGINX Plus</li>
                        <li><strong>Orchestrators:</strong> Kubernetes, Docker Swarm, OpenShift</li>
                        <li><strong>Monitoring:</strong> Nagios, Zabbix, Prometheus, Datadog</li>
                        <li><strong>Databases:</strong> MySQL/PostgreSQL Master-Slave, MongoDB ReplicaSet</li>
                        <li><strong>Storage:</strong> SAN/NAS clustering, distributed filesystems</li>
                        <li><strong>Network:</strong> BGP, VRRP, HSRP para redundancia de red</li>
                    </ul>
                </div>

                <div class="infrastructure-block">
                    <h3>üèÜ Beneficios de la Implementaci√≥n</h3>
                    <p><strong>Business Value Comprobado:</strong></p>
                    <ul>
                        <li>Reducci√≥n 95% tiempo de failover (30min ‚Üí 90seg)</li>
                        <li>Incremento 25% en customer satisfaction scores</li>
                        <li>Ahorro $2M/a√±o en p√©rdidas por downtime</li>
                        <li>Cumplimiento 100% SLAs Tier-1 clientes</li>
                        <li>Certificaci√≥n SOC2 Type II lograda</li>
                    </ul>
                </div>
            </div>

            <!-- Slide 2: Configuraci√≥n de Proyecto IT -->
            <div class="slide">
                <h2>üìÅ CONFIGURACI√ìN DE PROYECTO IT</h2>
                
                <div class="sla-card">
                    <h3>‚ö†Ô∏è PASO 1: Setup Quartus II para Sistemas Cr√≠ticos</h3>
                    <p>Configuraci√≥n de <strong>alta confiabilidad</strong> para centros de datos con consideraciones de <strong>timing distribuido</strong> y <strong>fault tolerance</strong></p>
                </div>

                <div class="steps-grid">
                    <div class="step-card">
                        <div class="step-number">1</div>
                        <h4>üöÄ NUEVO PROYECTO DATA CENTER</h4>
                        <ul>
                            <li>Abrir Quartus II v13.1</li>
                            <li>File ‚Üí New Project Wizard</li>
                            <li>Directorio: C:\datacenter_ha\flipflop_failover_controller</li>
                            <li>Nombre: flipflop_d_failover_ha</li>
                            <li>Versioning: Git integration habilitado</li>
                        </ul>
                    </div>
                    
                    <div class="step-card">
                        <div class="step-number">2</div>
                        <h4>üîß DISPOSITIVO PARA HA SYSTEMS</h4>
                        <ul>
                            <li>Family: MAX II (probado en datacenters)</li>
                            <li>Device: EPM240T100C5</li>
                            <li>Package: TQFP (rack mount compatible)</li>
                            <li>Speed Grade: 5 (timing cr√≠tico)</li>
                        </ul>
                    </div>
                    
                    <div class="step-card">
                        <div class="step-number">3</div>
                        <h4>‚öôÔ∏è HERRAMIENTAS Y METODOLOG√çAS</h4>
                        <ul>
                            <li>Simulation: ModelSim-Altera</li>
                            <li>Format: VHDL (industry standard)</li>
                            <li>Methodology: ITIL v4 compliant</li>
                            <li>Documentation: ITSM integrated</li>
                        </ul>
                    </div>
                </div>

                <div class="availability-card">
                    <h3>üìÅ Estructura de Proyecto Data Center</h3>
                    <div class="code-block-container">
                        <div class="language-label">Directorio HA Project</div>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                        <pre class="code-block">C:\datacenter_ha\flipflop_failover_controller\
‚îú‚îÄ‚îÄ flipflop_d_failover_ha.qpf              (Archivo de proyecto)
‚îú‚îÄ‚îÄ flipflop_d_failover_ha.qsf              (Configuraci√≥n HA)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ flipflop_d_failover_ha.vhd          (Dise√±o principal)
‚îÇ   ‚îú‚îÄ‚îÄ ha_interfaces.vhd                   (Interfaces HA)
‚îÇ   ‚îî‚îÄ‚îÄ network_protocols.vhd               (Protocolos red)
‚îú‚îÄ‚îÄ testbench/
‚îÇ   ‚îú‚îÄ‚îÄ tb_failover_scenarios.vhd           (Escenarios failover)
‚îÇ   ‚îú‚îÄ‚îÄ tb_network_partition.vhd            (Test split-brain)
‚îÇ   ‚îî‚îÄ‚îÄ tb_chaos_engineering.vhd            (Chaos testing)
‚îú‚îÄ‚îÄ simulation/
‚îÇ   ‚îî‚îÄ‚îÄ modelsim/                           (Simulaciones HA)
‚îú‚îÄ‚îÄ documentation/
‚îÇ   ‚îú‚îÄ‚îÄ system_architecture_v1_0.md        (Arquitectura sistema)
‚îÇ   ‚îú‚îÄ‚îÄ runbook_operations.md               (Runbook NOC 24/7)
‚îÇ   ‚îú‚îÄ‚îÄ disaster_recovery_plan.md           (DR procedures)
‚îÇ   ‚îî‚îÄ‚îÄ sla_compliance_report.pdf          (SLA metrics)
‚îú‚îÄ‚îÄ monitoring/
‚îÇ   ‚îú‚îÄ‚îÄ nagios_checks.cfg                   (Nagios monitoring)
‚îÇ   ‚îú‚îÄ‚îÄ prometheus_rules.yml               (Prometheus alerts)
‚îÇ   ‚îî‚îÄ‚îÄ grafana_dashboard.json              (Grafana visualization)
‚îú‚îÄ‚îÄ deployment/
‚îÇ   ‚îú‚îÄ‚îÄ ansible_playbook.yml               (Infrastructure as Code)
‚îÇ   ‚îú‚îÄ‚îÄ docker_compose.yml                 (Container deployment)
‚îÇ   ‚îî‚îÄ‚îÄ kubernetes_manifests/              (K8s deployment)
‚îî‚îÄ‚îÄ output_files/                          (Compiled artifacts)</pre>
                    </div>
                </div>

                <div class="monitoring-card">
                    <h3>üîß Configuraciones Espec√≠ficas para Data Center</h3>
                    
                    <div class="tab-container">
                        <button class="tab-button active" onclick="showTab('timing-datacenter')">Timing Distribuido</button>
                        <button class="tab-button" onclick="showTab('fault-tolerance')">Fault Tolerance</button>
                        <button class="tab-button" onclick="showTab('itil-documentation')">ITIL Documentation</button>
                    </div>
                    
                    <div id="timing-datacenter" class="tab-content active">
                        <div class="code-block-container">
                            <div class="language-label">QSF - Timing Data Center</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block"># ================================================
# CONFIGURACIONES DE TIMING PARA DATA CENTERS
# Compatible con sistemas distribuidos y clusters
# ================================================

# Configuraci√≥n de reloj para alta disponibilidad
set_global_assignment -name MIN_CORE_JUNCTION_TEMP 0
set_global_assignment -name MAX_CORE_JUNCTION_TEMP 85

# Timing constraints para heartbeat distribuido
set_global_assignment -name TIMEQUEST_MULTICORNER_ANALYSIS ON
set_global_assignment -name TIMEQUEST_DO_CCPP_REMOVAL ON

# Configuraci√≥n anti-metaestabilidad cr√≠tica
set_global_assignment -name SYNCHRONIZER_IDENTIFICATION AUTO
set_global_assignment -name TIMEQUEST_REPORT_SCRIPT_INCLUDE_DEFAULT_ANALYSIS ON

# Configuraci√≥n de robustez para rack environment
set_global_assignment -name ENABLE_CONFIGURATION_PINS OFF
set_global_assignment -name ENABLE_BOOT_SEL_PIN OFF

# Optimizaci√≥n para alta disponibilidad
set_global_assignment -name OPTIMIZATION_TECHNIQUE SPEED
set_global_assignment -name ALLOW_POWER_UP_DONT_CARE OFF

# Clock domain crossing para sistemas distribuidos
set_global_assignment -name ENABLE_CLOCK_LATENCY ON
set_global_assignment -name OPTIMIZE_HOLD_TIMING "ALL PATHS"

# Configuraci√≥n para network timing
set_global_assignment -name AUTO_GLOBAL_CLOCK_MAX 2
set_global_assignment -name AUTO_GLOBAL_REGISTER_CONTROLS ON

# Timing constraints espec√≠ficos para HA
create_clock -name {heartbeat_clk} -period 1000.000 -waveform { 0.000 500.000 } [get_ports {heartbeat_in}]
create_clock -name {system_clk} -period 20.000 -waveform { 0.000 10.000 } [get_ports {clk_50mhz}]

# Network timing constraints
set_input_delay -clock [get_clocks heartbeat_clk] -max 100.0 [get_ports network_status]
set_input_delay -clock [get_clocks heartbeat_clk] -min 10.0 [get_ports network_status]
set_output_delay -clock [get_clocks system_clk] -max 50.0 [get_ports failover_trigger]
set_output_delay -clock [get_clocks system_clk] -min 5.0 [get_ports failover_trigger]</pre>
                        </div>
                    </div>
                    
                    <div id="fault-tolerance" class="tab-content">
                        <div class="code-block-container">
                            <div class="language-label">QSF - Fault Tolerance</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block"># ================================================
# CONFIGURACIONES DE FAULT TOLERANCE PARA HA
# Resistencia a fallos de hardware y red
# ================================================

# Configuraci√≥n I/O para alta confiabilidad
set_global_assignment -name RESERVE_ALL_UNUSED_PINS "AS INPUT TRI-STATED WITH WEAK PULL-UP"
set_global_assignment -name RESERVE_ALL_UNUSED_PINS_NO_OUTPUT_GND "AS INPUT TRI-STATED"

# Configuraci√≥n de drive strength para se√±ales cr√≠ticas
set_instance_assignment -name CURRENT_STRENGTH_NEW "MAXIMUM CURRENT" -to failover_signal
set_instance_assignment -name CURRENT_STRENGTH_NEW "MAXIMUM CURRENT" -to active_server_out

# Error detection and correction
set_global_assignment -name ENABLE_ERROR_DETECTION_ERROR_CORRECTION ON
set_global_assignment -name ENABLE_SINGLE_EVENT_UPSET_MITIGATION ON

# Redundant configuration for critical signals
set_instance_assignment -name DUPLICATE_ENTITY ON -to critical_failover_logic
set_instance_assignment -name ENABLE_BUS_HOLD_CIRCUITRY ON -to heartbeat_in

# Power-up behavior for HA systems
set_global_assignment -name POWER_UP_LEVEL LOW
set_global_assignment -name POWER_DOWN_LEVEL LOW

# Clock redundancy for mission critical operations
set_global_assignment -name ENABLE_DEVICE_WIDE_RESET ON
set_global_assignment -name USE_CHECKSUM_AS_USERCODE OFF

# Network interface protection
set_instance_assignment -name WEAK_PULL_UP_RESISTOR ON -to network_enable
set_instance_assignment -name WEAK_PULL_UP_RESISTOR ON -to cluster_heartbeat

# Triple modular redundancy for critical paths
set_instance_assignment -name DUPLICATE_REGISTER ON -to failover_state_reg
set_instance_assignment -name ENABLE_LOCK_PROTECTION ON -to *

# Hot-standby configuration
set_global_assignment -name ENABLE_CONFIGURATION_PINS OFF
set_global_assignment -name ENABLE_JTAG_LOCK_PROTECTION OFF

# Environmental protection
set_global_assignment -name DEVICE_FILTER_PACKAGE TQFP
set_global_assignment -name DEVICE_FILTER_SPEED_GRADE 5</pre>
                        </div>
                    </div>
                    
                    <div id="itil-documentation" class="tab-content">
                        <div class="code-block-container">
                            <div class="language-label">ITIL v4 Configuration</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block"># ================================================
# CONFIGURACIONES SEG√öN ITIL v4 Y MEJORES PR√ÅCTICAS IT
# Change Management y Configuration Management
# ================================================

# Informaci√≥n de configuraci√≥n CMDB
set_global_assignment -name PROJECT_CREATION_TIME_DATE "$(date)"
set_global_assignment -name LAST_QUARTUS_VERSION "13.1.0 Build 162"
set_global_assignment -name PROJECT_OWNER "Infrastructure Team"
set_global_assignment -name PROJECT_BUSINESS_UNIT "Data Center Operations"

# Change management metadata
set_global_assignment -name CHANGE_REQUEST_ID "CHG-2024-001234"
set_global_assignment -name APPROVAL_STATUS "CAB_APPROVED"
set_global_assignment -name IMPLEMENTATION_WINDOW "MAINT-2024-Q1-001"

# Configuration item information
set_global_assignment -name CI_CATEGORY "Hardware Logic Component"
set_global_assignment -name CI_SUBCATEGORY "Failover Controller"
set_global_assignment -name CI_STATUS "PRODUCTION"
set_global_assignment -name CI_ENVIRONMENT "PROD-DC-PRIMARY"

# Service Level Agreement metadata
set_global_assignment -name SLA_TIER "TIER_1_CRITICAL"
set_global_assignment -name AVAILABILITY_REQUIREMENT "99.99"
set_global_assignment -name RTO_MINUTES "5"
set_global_assignment -name RPO_SECONDS "60"

# Incident and Problem Management
set_global_assignment -name ESCALATION_CONTACT "noc@company.com"
set_global_assignment -name VENDOR_SUPPORT "intel-fpga-support@intel.com"
set_global_assignment -name INTERNAL_EXPERT "john.smith@company.com"

# Asset management
set_global_assignment -name ASSET_TAG "DC-FPGA-HA-001"
set_global_assignment -name PROCUREMENT_PO "PO-2023-567890"
set_global_assignment -name WARRANTY_EXPIRY "2026-12-31"
set_global_assignment -name EOL_DATE "2030-12-31"

# Backup and recovery configuration
set_global_assignment -name BACKUP_SCHEDULE "DAILY_2AM_UTC"
set_global_assignment -name BACKUP_LOCATION "s3://company-backup/fpga-configs/"
set_global_assignment -name RECOVERY_PROCEDURE "RP-FPGA-HA-001"

# Monitoring and alerting
set_global_assignment -name NAGIOS_CONFIG "nagios-ha-fpga.cfg"
set_global_assignment -name PROMETHEUS_ENDPOINT "http://monitoring:9090/metrics"
set_global_assignment -name GRAFANA_DASHBOARD "dashboard-ha-fpga-001"

# Compliance and audit
set_global_assignment -name SOC2_COMPLIANT "YES"
set_global_assignment -name ISO27001_SCOPE "IN_SCOPE"
set_global_assignment -name AUDIT_TRAIL_ENABLED "YES"
set_global_assignment -name DATA_CLASSIFICATION "INTERNAL_CONFIDENTIAL"

# Version control and deployment
set_global_assignment -name GIT_REPOSITORY "git@company.com:infrastructure/ha-fpga.git"
set_global_assignment -name CI_CD_PIPELINE "jenkins-ha-fpga-deploy"
set_global_assignment -name DEPLOYMENT_METHOD "ANSIBLE_AUTOMATED"</pre>
                        </div>
                    </div>
                </div>

                <div class="datacenter-metrics">
                    <h3>‚úÖ Verificaci√≥n de Configuraci√≥n Data Center</h3>
                    <ul>
                        <li>‚úì Proyecto aparece en Project Navigator con estructura HA</li>
                        <li>‚úì Dispositivo EPM240T100C5 para rack environment</li>
                        <li>‚úì ModelSim configurado para chaos testing</li>
                        <li>‚úì Documentaci√≥n ITIL v4 generada autom√°ticamente</li>
                        <li>‚úì Timing constraints para sistemas distribuidos</li>
                        <li>‚úì Fault tolerance settings para mission critical</li>
                        <li>‚úì Integraci√≥n con CMDB y change management</li>
                        <li>‚úì Monitoring endpoints configurados</li>
                    </ul>
                </div>
            </div>

            <!-- Slide 3: VHDL para Sistemas de Alta Disponibilidad -->
            <div class="slide">
                <h2>üìù VHDL PARA SISTEMAS DE ALTA DISPONIBILIDAD</h2>
                
                <div class="infrastructure-block">
                    <h3>üèóÔ∏è Arquitectura FLIP FLOP D para Failover</h3>
                    <p>Dise√±o robusto con <strong>detecci√≥n de split-brain</strong>, <strong>timeouts configurables</strong> y <strong>interfaces para protocolos de red est√°ndar</strong></p>
                </div>

                <div class="tab-container">
                    <button class="tab-button active" onclick="showTab('flipflop-ha')">FLIP FLOP HA</button>
                    <button class="tab-button" onclick="showTab('network-interfaces')">Network Interfaces</button>
                    <button class="tab-button" onclick="showTab('monitoring-integration')">Monitoring Integration</button>
                </div>
                
                <div id="flipflop-ha" class="tab-content active">
                    <div class="availability-card">
                        <h3>üè¢ Dise√±o Principal: flipflop_d_failover_ha.vhd</h3>
                        <p><strong>FLIP FLOP D con funciones de alta disponibilidad para data centers</strong></p>
                        
                        <div class="code-block-container">
                            <div class="language-label">VHDL - High Availability</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block">-- ================================================
-- FLIP FLOP D PARA ALTA DISPONIBILIDAD EN DATA CENTERS
-- Aplicaci√≥n: Controlador Failover Autom√°tico de Servidores
-- Est√°ndar: Compatible con ITIL v4, SOC2, ISO 27001
-- Autor: Sistemas Digitales - Tecnolog√≠as de la Informaci√≥n
-- Versi√≥n: 1.0 - Validado para producci√≥n 24/7
-- ================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity flipflop_d_failover_ha is
    generic (
        -- Par√°metros configurables para diferentes SLAs
        HEARTBEAT_TIMEOUT_MS    : positive := 5000;   -- 5 segundos timeout
        FAILOVER_DELAY_MS       : positive := 1000;   -- 1 segundo delay switchover
        HEALTH_CHECK_PERIOD_MS  : positive := 100;    -- 100ms health check
        SPLIT_BRAIN_DETECT_MS   : positive := 2000;   -- 2 segundos split-brain
        ENABLE_MONITORING       : boolean  := true;   -- Habilitar SNMP/metrics
        ENABLE_LOGGING          : boolean  := true    -- Habilitar audit log
    );
    port (
        -- === INTERFACES DE SISTEMA ===
        clk_datacenter      : in  std_logic;  -- Reloj maestro datacenter (100MHz)
        heartbeat_cluster   : in  std_logic;  -- Heartbeat cluster manager (1Hz)
        reset_emergency     : in  std_logic;  -- Reset emergencia NOC (activo bajo)
        
        -- === ENTRADAS DE MONITOREO ===
        server_health_primary   : in  std_logic;  -- Health check servidor primario
        server_health_secondary : in  std_logic;  -- Health check servidor secundario
        network_connectivity    : in  std_logic;  -- Estado conectividad red
        maintenance_mode        : in  std_logic;  -- Maintenance window activo
        
        -- === INTERFACES DE RED ===
        load_balancer_status    : in  std_logic;  -- Estado load balancer
        database_sync_ok        : in  std_logic;  -- Sincronizaci√≥n BD OK
        storage_cluster_ok      : in  std_logic;  -- Storage cluster healthy
        
        -- === SALIDAS DE CONTROL ===
        primary_server_active   : out std_logic;  -- Q: Servidor primario activo
        secondary_server_active : out std_logic;  -- Q_N: Servidor secundario activo
        failover_in_progress    : out std_logic;  -- Failover ejecut√°ndose
        system_health_ok        : out std_logic;  -- Sistema general healthy
        
        -- === INTERFACES DE MONITOREO ===
        snmp_trap_trigger       : out std_logic;  -- Trigger SNMP trap
        syslog_event_trigger    : out std_logic;  -- Trigger syslog event
        prometheus_metrics      : out std_logic_vector(7 downto 0);  -- M√©tricas
        
        -- === DIAGN√ìSTICO AVANZADO ===
        ha_state_debug          : out std_logic_vector(3 downto 0);  -- Estado HA
        last_failover_cause     : out std_logic_vector(3 downto 0);  -- Causa √∫ltimo failover
        uptime_counter          : out std_logic_vector(31 downto 0)  -- Contador uptime
    );
end flipflop_d_failover_ha;

architecture high_availability of flipflop_d_failover_ha is
    
    -- === SE√ëALES INTERNAS ===
    signal heartbeat_sync       : std_logic_vector(2 downto 0);
    signal health_primary_sync  : std_logic_vector(2 downto 0);
    signal health_secondary_sync: std_logic_vector(2 downto 0);
    signal network_sync         : std_logic_vector(2 downto 0);
    
    signal heartbeat_valid      : std_logic;
    signal primary_healthy      : std_logic;
    signal secondary_healthy    : std_logic;
    signal network_ok           : std_logic;
    signal q_internal           : std_logic;
    
    -- === CONTADORES PARA TIMEOUTS ===
    signal heartbeat_counter    : unsigned(31 downto 0) := (others => '0');
    signal failover_counter     : unsigned(31 downto 0) := (others => '0');
    signal health_check_counter : unsigned(31 downto 0) := (others => '0');
    signal split_brain_counter  : unsigned(31 downto 0) := (others => '0');
    signal uptime_internal      : unsigned(31 downto 0) := (others => '0');
    
    -- === ESTADOS DEL SISTEMA HA ===
    type ha_state_t is (
        HA_INIT,           -- Inicializando sistema
        HA_PRIMARY_ACTIVE, -- Primario activo, secundario standby
        HA_SECONDARY_ACTIVE,-- Secundario activo, primario standby
        HA_FAILOVER,       -- Proceso de failover en curso
        HA_SPLIT_BRAIN,    -- Detecci√≥n split-brain
        HA_MAINTENANCE,    -- Modo mantenimiento
        HA_DISASTER        -- Ambos servidores fallan
    );
    signal ha_current_state : ha_state_t := HA_INIT;
    signal ha_previous_state: ha_state_t := HA_INIT;
    
    -- === CAUSAS DE FAILOVER ===
    type failover_cause_t is (
        CAUSE_NONE,
        CAUSE_PRIMARY_HEALTH,
        CAUSE_NETWORK_FAILURE,
        CAUSE_HEARTBEAT_LOST,
        CAUSE_MANUAL_SWITCH,
        CAUSE_STORAGE_FAILURE,
        CAUSE_LOAD_BALANCER,
        CAUSE_DATABASE_SYNC
    );
    signal current_failover_cause : failover_cause_t := CAUSE_NONE;
    
    -- === CONTADORES DE M√âTRICAS ===
    signal failover_count       : unsigned(15 downto 0) := (others => '0');
    signal availability_metric  : unsigned(7 downto 0) := (others => '0');
    
    -- === CONSTANTES DE TIEMPO ===
    constant CLK_FREQ_HZ : positive := 100000000; -- 100MHz
    constant HEARTBEAT_TIMEOUT_CYCLES : positive := 
        HEARTBEAT_TIMEOUT_MS * (CLK_FREQ_HZ / 1000);
    constant FAILOVER_DELAY_CYCLES : positive := 
        FAILOVER_DELAY_MS * (CLK_FREQ_HZ / 1000);
    constant HEALTH_CHECK_CYCLES : positive := 
        HEALTH_CHECK_PERIOD_MS * (CLK_FREQ_HZ / 1000);
    constant SPLIT_BRAIN_CYCLES : positive := 
        SPLIT_BRAIN_DETECT_MS * (CLK_FREQ_HZ / 1000);

begin

    -- ================================================
    -- PROCESO: SINCRONIZACI√ìN DE SE√ëALES CR√çTICAS
    -- Elimina metaestabilidad en entradas del datacenter
    -- ================================================
    process(clk_datacenter, reset_emergency)
    begin
        if reset_emergency = '0' then
            heartbeat_sync <= (others => '0');
            health_primary_sync <= (others => '0');
            health_secondary_sync <= (others => '0');
            network_sync <= (others => '0');
        elsif rising_edge(clk_datacenter) then
            -- Sincronizaci√≥n con cadena de flip-flops para evitar metaestabilidad
            heartbeat_sync <= heartbeat_sync(1 downto 0) & heartbeat_cluster;
            health_primary_sync <= health_primary_sync(1 downto 0) & server_health_primary;
            health_secondary_sync <= health_secondary_sync(1 downto 0) & server_health_secondary;
            network_sync <= network_sync(1 downto 0) & network_connectivity;
        end if;
    end process;

    -- Asignaci√≥n de se√±ales sincronizadas
    heartbeat_valid <= heartbeat_sync(2);
    primary_healthy <= health_primary_sync(2);
    secondary_healthy <= health_secondary_sync(2);
    network_ok <= network_sync(2);

    -- ================================================
    -- PROCESO: MONITOREO DE HEARTBEAT DEL CLUSTER
    -- Detecta p√©rdida de comunicaci√≥n con cluster manager
    -- ================================================
    process(clk_datacenter, reset_emergency)
        variable heartbeat_prev : std_logic := '0';
    begin
        if reset_emergency = '0' then
            heartbeat_counter <= (others => '0');
            heartbeat_prev := '0';
        elsif rising_edge(clk_datacenter) then
            -- Detecci√≥n de flanco en heartbeat
            if heartbeat_valid = '1' and heartbeat_prev = '0' then
                heartbeat_counter <= (others => '0'); -- Reset contador en heartbeat
            else
                if heartbeat_counter < HEARTBEAT_TIMEOUT_CYCLES then
                    heartbeat_counter <= heartbeat_counter + 1;
                end if;
            end if;
            heartbeat_prev := heartbeat_valid;
        end if;
    end process;

    -- ================================================
    -- PROCESO: HEALTH CHECK PERI√ìDICO
    -- Monitoreo continuo de componentes cr√≠ticos
    -- ================================================
    process(clk_datacenter, reset_emergency)
    begin
        if reset_emergency = '0' then
            health_check_counter <= (others => '0');
        elsif rising_edge(clk_datacenter) then
            if health_check_counter >= HEALTH_CHECK_CYCLES then
                health_check_counter <= (others => '0');
                -- Trigger para health check (implementar l√≥gica espec√≠fica)
            else
                health_check_counter <= health_check_counter + 1;
            end if;
        end if;
    end process;

    -- ================================================
    -- PROCESO: M√ÅQUINA DE ESTADOS DE ALTA DISPONIBILIDAD
    -- Control principal del sistema de failover
    -- ================================================
    process(clk_datacenter, reset_emergency)
        variable heartbeat_expired : boolean;
        variable both_servers_healthy : boolean;
        variable any_server_healthy : boolean;
    begin
        if reset_emergency = '0' then
            ha_current_state <= HA_INIT;
            ha_previous_state <= HA_INIT;
            q_internal <= '0';
            current_failover_cause <= CAUSE_NONE;
            failover_counter <= (others => '0');
            split_brain_counter <= (others => '0');
        elsif rising_edge(clk_datacenter) then
            
            -- Variables auxiliares
            heartbeat_expired := (heartbeat_counter >= HEARTBEAT_TIMEOUT_CYCLES);
            both_servers_healthy := (primary_healthy = '1' and secondary_healthy = '1');
            any_server_healthy := (primary_healthy = '1' or secondary_healthy = '1');
            
            ha_previous_state <= ha_current_state;
            
            case ha_current_state is
                
                when HA_INIT =>
                    q_internal <= '0';
                    current_failover_cause <= CAUSE_NONE;
                    failover_counter <= (others => '0');
                    
                    if maintenance_mode = '1' then
                        ha_current_state <= HA_MAINTENANCE;
                    elsif both_servers_healthy and network_ok = '1' and not heartbeat_expired then
                        ha_current_state <= HA_PRIMARY_ACTIVE;
                        q_internal <= '1'; -- Primario activo por defecto
                    elsif secondary_healthy = '1' and network_ok = '1' then
                        ha_current_state <= HA_SECONDARY_ACTIVE;
                        q_internal <= '0'; -- Secundario activo
                    end if;
                
                when HA_PRIMARY_ACTIVE =>
                    q_internal <= '1';
                    
                    if maintenance_mode = '1' then
                        ha_current_state <= HA_MAINTENANCE;
                    elsif primary_healthy = '0' then
                        -- Primario fall√≥, iniciar failover
                        current_failover_cause <= CAUSE_PRIMARY_HEALTH;
                        ha_current_state <= HA_FAILOVER;
                        failover_counter <= (others => '0');
                    elsif network_ok = '0' then
                        current_failover_cause <= CAUSE_NETWORK_FAILURE;
                        ha_current_state <= HA_SPLIT_BRAIN;
                        split_brain_counter <= (others => '0');
                    elsif heartbeat_expired then
                        current_failover_cause <= CAUSE_HEARTBEAT_LOST;
                        ha_current_state <= HA_FAILOVER;
                        failover_counter <= (others => '0');
                    elsif load_balancer_status = '0' then
                        current_failover_cause <= CAUSE_LOAD_BALANCER;
                        ha_current_state <= HA_FAILOVER;
                        failover_counter <= (others => '0');
                    elsif database_sync_ok = '0' then
                        current_failover_cause <= CAUSE_DATABASE_SYNC;
                        ha_current_state <= HA_FAILOVER;
                        failover_counter <= (others => '0');
                    end if;
                
                when HA_SECONDARY_ACTIVE =>
                    q_internal <= '0';
                    
                    if maintenance_mode = '1' then
                        ha_current_state <= HA_MAINTENANCE;
                    elsif secondary_healthy = '0' then
                        -- Secundario fall√≥, volver a primario si est√° healthy
                        if primary_healthy = '1' then
                            current_failover_cause <= CAUSE_PRIMARY_HEALTH;
                            ha_current_state <= HA_FAILOVER;
                            failover_counter <= (others => '0');
                        else
                            ha_current_state <= HA_DISASTER;
                        end if;
                    elsif primary_healthy = '1' and secondary_healthy = '1' and network_ok = '1' then
                        -- Ambos healthy, preferir primario
                        current_failover_cause <= CAUSE_MANUAL_SWITCH;
                        ha_current_state <= HA_FAILOVER;
                        failover_counter <= (others => '0');
                    end if;
                
                when HA_FAILOVER =>
                    failover_counter <= failover_counter + 1;
                    
                    if failover_counter >= FAILOVER_DELAY_CYCLES then
                        -- Completar failover
                        if ha_previous_state = HA_PRIMARY_ACTIVE then
                            if secondary_healthy = '1' then
                                ha_current_state <= HA_SECONDARY_ACTIVE;
                                q_internal <= '0';
                                failover_count <= failover_count + 1;
                            else
                                ha_current_state <= HA_DISASTER;
                            end if;
                        elsif ha_previous_state = HA_SECONDARY_ACTIVE then
                            if primary_healthy = '1' then
                                ha_current_state <= HA_PRIMARY_ACTIVE;
                                q_internal <= '1';
                                failover_count <= failover_count + 1;
                            else
                                ha_current_state <= HA_DISASTER;
                            end if;
                        end if;
                        current_failover_cause <= CAUSE_NONE;
                    end if;
                
                when HA_SPLIT_BRAIN =>
                    -- Mantener estado actual durante split-brain
                    split_brain_counter <= split_brain_counter + 1;
                    
                    if split_brain_counter >= SPLIT_BRAIN_CYCLES then
                        -- Timeout split-brain, forzar a estado conocido
                        if primary_healthy = '1' then
                            ha_current_state <= HA_PRIMARY_ACTIVE;
                            q_internal <= '1';
                        elsif secondary_healthy = '1' then
                            ha_current_state <= HA_SECONDARY_ACTIVE;
                            q_internal <= '0';
                        else
                            ha_current_state <= HA_DISASTER;
                        end if;
                    elsif network_ok = '1' then
                        -- Red recuperada, volver a estado anterior
                        if q_internal = '1' then
                            ha_current_state <= HA_PRIMARY_ACTIVE;
                        else
                            ha_current_state <= HA_SECONDARY_ACTIVE;
                        end if;
                    end if;
                
                when HA_MAINTENANCE =>
                    -- Durante mantenimiento, mantener estado actual
                    if maintenance_mode = '0' then
                        if both_servers_healthy and network_ok = '1' then
                            ha_current_state <= HA_PRIMARY_ACTIVE;
                            q_internal <= '1';
                        elsif any_server_healthy then
                            if primary_healthy = '1' then
                                ha_current_state <= HA_PRIMARY_ACTIVE;
                                q_internal <= '1';
                            else
                                ha_current_state <= HA_SECONDARY_ACTIVE;
                                q_internal <= '0';
                            end if;
                        else
                            ha_current_state <= HA_DISASTER;
                        end if;
                    end if;
                
                when HA_DISASTER =>
                    q_internal <= '0'; -- Estado seguro
                    
                    if any_server_healthy and network_ok = '1' and not heartbeat_expired then
                        if primary_healthy = '1' then
                            ha_current_state <= HA_PRIMARY_ACTIVE;
                            q_internal <= '1';
                        else
                            ha_current_state <= HA_SECONDARY_ACTIVE;
                            q_internal <= '0';
                        end if;
                    end if;
                
            end case;
        end if;
    end process;

    -- ================================================
    -- PROCESO: CONTADOR DE UPTIME Y M√âTRICAS
    -- ================================================
    process(clk_datacenter, reset_emergency)
    begin
        if reset_emergency = '0' then
            uptime_internal <= (others => '0');
            availability_metric <= (others => '0');
        elsif rising_edge(clk_datacenter) then
            -- Contador de uptime (incrementa cada segundo)
            if uptime_internal(25 downto 0) = 100000000-1 then -- 1 segundo @ 100MHz
                uptime_internal <= uptime_internal + 1;
                
                -- Calcular m√©trica de disponibilidad
                if ha_current_state = HA_PRIMARY_ACTIVE or ha_current_state = HA_SECONDARY_ACTIVE then
                    if availability_metric < 255 then
                        availability_metric <= availability_metric + 1;
                    end if;
                else
                    if availability_metric > 0 then
                        availability_metric <= availability_metric - 1;
                    end if;
                end if;
            else
                uptime_internal(25 downto 0) <= uptime_internal(25 downto 0) + 1;
            end if;
        end if;
    end process;

    -- ================================================
    -- ASIGNACI√ìN DE SALIDAS
    -- ================================================
    primary_server_active <= q_internal;
    secondary_server_active <= not q_internal;
    
    failover_in_progress <= '1' when ha_current_state = HA_FAILOVER else '0';
    
    system_health_ok <= '1' when (ha_current_state = HA_PRIMARY_ACTIVE or 
                                 ha_current_state = HA_SECONDARY_ACTIVE) and
                                network_ok = '1' else '0';
    
    -- Triggers para monitoreo
    snmp_trap_trigger <= '1' when (ha_current_state /= ha_previous_state and 
                                  ha_current_state = HA_FAILOVER) else '0';
    
    syslog_event_trigger <= '1' when (ha_current_state = HA_SPLIT_BRAIN or 
                                     ha_current_state = HA_DISASTER) else '0';
    
    -- M√©tricas para Prometheus
    prometheus_metrics <= std_logic_vector(availability_metric);
    
    -- Debug y diagn√≥stico
    ha_state_debug <= std_logic_vector(to_unsigned(ha_state_t'pos(ha_current_state), 4));
    last_failover_cause <= std_logic_vector(to_unsigned(failover_cause_t'pos(current_failover_cause), 4));
    uptime_counter <= std_logic_vector(uptime_internal);

end high_availability;</pre>
                        </div>
                    </div>
                </div>
                
                <div id="network-interfaces" class="tab-content">
                    <div class="monitoring-card">
                        <h3>üåê Interfaces para Protocolos de Red</h3>
                        <p>Adaptadores para integraci√≥n con <strong>load balancers</strong>, <strong>DNS</strong> y <strong>sistemas de orquestaci√≥n</strong></p>
                        
                        <div class="code-block-container">
                            <div class="language-label">VHDL - Network Interfaces</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block">-- ================================================
-- INTERFACES DE RED PARA INTEGRACI√ìN DATACENTER
-- Compatible con F5, HAProxy, Kubernetes, etc.
-- ================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity network_ha_interfaces is
    port (
        -- === INTERFACE FPGA (NIVELES TTL) ===
        fpga_clk_100mhz        : in  std_logic;
        fpga_reset_n           : in  std_logic;
        fpga_primary_active    : in  std_logic;
        fpga_secondary_active  : in  std_logic;
        fpga_failover_trigger  : out std_logic;
        
        -- === INTERFACES LOAD BALANCER ===
        lb_health_check_primary   : in  std_logic;   -- Health check from F5/HAProxy
        lb_health_check_secondary : in  std_logic;   -- Health check backup
        lb_virtual_ip_primary     : out std_logic;   -- Control VIP primario
        lb_virtual_ip_secondary   : out std_logic;   -- Control VIP secundario
        
        -- === INTERFACES DNS DIN√ÅMICO ===
        dns_update_trigger        : out std_logic;   -- Trigger actualizaci√≥n DNS
        dns_record_type           : out std_logic_vector(1 downto 0); -- A/AAAA/CNAME
        dns_ttl_override          : out std_logic;   -- Override TTL a valor bajo
        
        -- === INTERFACES KUBERNETES/ORCHESTRATOR ===
        k8s_pod_ready_primary     : in  std_logic;   -- Pod readiness probe
        k8s_pod_ready_secondary   : in  std_logic;   -- Pod backup readiness
        k8s_service_selector      : out std_logic_vector(1 downto 0); -- Service selector
        k8s_ingress_backend       : out std_logic;   -- Ingress backend switch
        
        -- === INTERFACES MONITOREO SNMP ===
        snmp_oid_availability     : out std_logic_vector(7 downto 0); -- OID availability
        snmp_oid_failover_count   : out std_logic_vector(15 downto 0); -- OID failover count
        snmp_trap_critical        : out std_logic;   -- SNMP trap cr√≠tico
        snmp_community_string     : out std_logic_vector(31 downto 0); -- Community
        
        -- === INTERFACES DATABASE REPLICATION ===
        db_master_status          : in  std_logic;   -- DB master status
        db_slave_lag_ok           : in  std_logic;   -- Replication lag OK
        db_promote_slave          : out std_logic;   -- Promote slave to master
        db_demote_master          : out std_logic;   -- Demote current master
        
        -- === INTERFACES STORAGE CLUSTER ===
        storage_primary_online    : in  std_logic;   -- Primary storage online
        storage_secondary_online  : in  std_logic;   -- Secondary storage online
        storage_switch_primary    : out std_logic;   -- Switch to primary storage
        storage_sync_required     : out std_logic    -- Trigger storage sync
    );
end network_ha_interfaces;

architecture network_integration of network_ha_interfaces is
    
    -- Instancia del controlador principal
    component flipflop_d_failover_ha is
        generic (
            HEARTBEAT_TIMEOUT_MS    : positive := 5000;
            FAILOVER_DELAY_MS       : positive := 1000;
            HEALTH_CHECK_PERIOD_MS  : positive := 100;
            SPLIT_BRAIN_DETECT_MS   : positive := 2000;
            ENABLE_MONITORING       : boolean  := true;
            ENABLE_LOGGING          : boolean  := true
        );
        port (
            clk_datacenter         : in  std_logic;
            heartbeat_cluster      : in  std_logic;
            reset_emergency        : in  std_logic;
            server_health_primary  : in  std_logic;
            server_health_secondary: in  std_logic;
            network_connectivity   : in  std_logic;
            maintenance_mode       : in  std_logic;
            load_balancer_status   : in  std_logic;
            database_sync_ok       : in  std_logic;
            storage_cluster_ok     : in  std_logic;
            primary_server_active  : out std_logic;
            secondary_server_active: out std_logic;
            failover_in_progress   : out std_logic;
            system_health_ok       : out std_logic;
            snmp_trap_trigger      : out std_logic;
            syslog_event_trigger   : out std_logic;
            prometheus_metrics     : out std_logic_vector(7 downto 0);
            ha_state_debug         : out std_logic_vector(3 downto 0);
            last_failover_cause    : out std_logic_vector(3 downto 0);
            uptime_counter         : out std_logic_vector(31 downto 0)
        );
    end component;
    
    -- === SE√ëALES INTERMEDIAS ===
    signal heartbeat_synthesized    : std_logic;
    signal primary_active_internal  : std_logic;
    signal secondary_active_internal: std_logic;
    signal failover_in_progress     : std_logic;
    signal system_healthy           : std_logic;
    signal snmp_trap_active         : std_logic;
    signal prometheus_data          : std_logic_vector(7 downto 0);
    signal uptime_seconds           : std_logic_vector(31 downto 0);
    
    -- === CONTADORES Y REGISTROS ===
    signal failover_count_reg       : unsigned(15 downto 0) := (others => '0');
    signal dns_update_pending       : std_logic := '0';
    signal lb_switch_pending        : std_logic := '0';
    
    -- === SE√ëALES DE ESTADO PREVIO ===
    signal primary_active_prev      : std_logic := '0';
    signal secondary_active_prev    : std_logic := '0';
    
begin

    -- ================================================
    -- GENERACI√ìN DE HEARTBEAT SINT√âTICO
    -- Simula heartbeat para testing y desarrollo
    -- ================================================
    process(fpga_clk_100mhz, fpga_reset_n)
        variable heartbeat_counter : unsigned(25 downto 0) := (others => '0');
    begin
        if fpga_reset_n = '0' then
            heartbeat_counter := (others => '0');
            heartbeat_synthesized <= '0';
        elsif rising_edge(fpga_clk_100mhz) then
            if heartbeat_counter = 100000000-1 then -- 1 segundo @ 100MHz
                heartbeat_counter := (others => '0');
                heartbeat_synthesized <= not heartbeat_synthesized;
            else
                heartbeat_counter := heartbeat_counter + 1;
            end if;
        end if;
    end process;

    -- ================================================
    -- INSTANCIACI√ìN DEL CONTROLADOR PRINCIPAL HA
    -- ================================================
    ha_controller: flipflop_d_failover_ha
        generic map (
            HEARTBEAT_TIMEOUT_MS    => 5000,    -- 5 segundos timeout
            FAILOVER_DELAY_MS       => 1000,    -- 1 segundo delay
            HEALTH_CHECK_PERIOD_MS  => 100,     -- 100ms health check
            SPLIT_BRAIN_DETECT_MS   => 2000,    -- 2 segundos split-brain
            ENABLE_MONITORING       => true,    -- Monitoreo habilitado
            ENABLE_LOGGING          => true     -- Logging habilitado
        )
        port map (
            clk_datacenter         => fpga_clk_100mhz,
            heartbeat_cluster      => heartbeat_synthesized,
            reset_emergency        => fpga_reset_n,
            server_health_primary  => lb_health_check_primary,
            server_health_secondary=> lb_health_check_secondary,
            network_connectivity   => '1',  -- Simplificado para demo
            maintenance_mode       => '0',  -- Controlado externamente
            load_balancer_status   => '1',  -- Monitoreado externamente
            database_sync_ok       => db_slave_lag_ok,
            storage_cluster_ok     => storage_primary_online and storage_secondary_online,
            primary_server_active  => primary_active_internal,
            secondary_server_active=> secondary_active_internal,
            failover_in_progress   => failover_in_progress,
            system_health_ok       => system_healthy,
            snmp_trap_trigger      => snmp_trap_active,
            syslog_event_trigger   => open,
            prometheus_metrics     => prometheus_data,
            ha_state_debug         => open,
            last_failover_cause    => open,
            uptime_counter         => uptime_seconds
        );

    -- ================================================
    -- PROCESO: CONTROL DE LOAD BALANCER
    -- Gestiona VIPs y health checks
    -- ================================================
    process(fpga_clk_100mhz, fpga_reset_n)
    begin
        if fpga_reset_n = '0' then
            lb_virtual_ip_primary <= '0';
            lb_virtual_ip_secondary <= '0';
            lb_switch_pending <= '0';
            primary_active_prev <= '0';
            secondary_active_prev <= '0';
        elsif rising_edge(fpga_clk_100mhz) then
            primary_active_prev <= primary_active_internal;
            secondary_active_prev <= secondary_active_internal;
            
            -- Detectar cambio de estado para switchover
            if primary_active_internal /= primary_active_prev or
               secondary_active_internal /= secondary_active_prev then
                lb_switch_pending <= '1';
            end if;
            
            -- Actualizar VIPs seg√∫n estado activo
            if primary_active_internal = '1' then
                lb_virtual_ip_primary <= '1';
                lb_virtual_ip_secondary <= '0';
            else
                lb_virtual_ip_primary <= '0';
                lb_virtual_ip_secondary <= '1';
            end if;
            
            -- Clear pending flags despu√©s de un ciclo
            if lb_switch_pending = '1' then
                lb_switch_pending <= '0';
            end if;
        end if;
    end process;

    -- ================================================
    -- PROCESO: CONTROL DE DNS DIN√ÅMICO
    -- Actualiza registros DNS autom√°ticamente
    -- ================================================
    process(fpga_clk_100mhz, fpga_reset_n)
        variable dns_update_delay : unsigned(15 downto 0) := (others => '0');
    begin
        if fpga_reset_n = '0' then
            dns_update_trigger <= '0';
            dns_record_type <= "00";  -- Tipo A por defecto
            dns_ttl_override <= '0';
            dns_update_pending <= '0';
            dns_update_delay := (others => '0');
        elsif rising_edge(fpga_clk_100mhz) then
            -- Trigger DNS update en cambio de servidor activo
            if lb_switch_pending = '1' then
                dns_update_pending <= '1';
                dns_ttl_override <= '1';  -- TTL bajo durante failover
                dns_update_delay := (others => '0');
            end if;
            
            -- Generar pulso de actualizaci√≥n DNS
            if dns_update_pending = '1' then
                if dns_update_delay < 1000 then -- Delay de 10us
                    dns_update_delay := dns_update_delay + 1;
                    dns_update_trigger <= '1';
                else
                    dns_update_trigger <= '0';
                    dns_update_pending <= '0';
                    dns_ttl_override <= '0';
                end if;
            else
                dns_update_trigger <= '0';
            end if;
            
            -- Configurar tipo de registro DNS
            dns_record_type <= "01";  -- Tipo A (IPv4)
        end if;
    end process;

    -- ================================================
    -- PROCESO: INTEGRACI√ìN KUBERNETES
    -- Control de services y ingress
    -- ================================================
    process(fpga_clk_100mhz, fpga_reset_n)
    begin
        if fpga_reset_n = '0' then
            k8s_service_selector <= "00";
            k8s_ingress_backend <= '0';
        elsif rising_edge(fpga_clk_100mhz) then
            -- Configurar selector de servicio Kubernetes
            if primary_active_internal = '1' and k8s_pod_ready_primary = '1' then
                k8s_service_selector <= "01";  -- Selector primario
                k8s_ingress_backend <= '1';    -- Backend primario
            elsif secondary_active_internal = '1' and k8s_pod_ready_secondary = '1' then
                k8s_service_selector <= "10";  -- Selector secundario
                k8s_ingress_backend <= '0';    -- Backend secundario
            else
                k8s_service_selector <= "00";  -- Sin selector
                k8s_ingress_backend <= '0';
            end if;
        end if;
    end process;

    -- ================================================
    -- PROCESO: CONTROL DE BASE DE DATOS
    -- Gestiona replicaci√≥n y promoci√≥n master/slave
    -- ================================================
    process(fpga_clk_100mhz, fpga_reset_n)
        variable db_switch_delay : unsigned(15 downto 0) := (others => '0');
        variable db_operation_pending : std_logic := '0';
    begin
        if fpga_reset_n = '0' then
            db_promote_slave <= '0';
            db_demote_master <= '0';
            db_switch_delay := (others => '0');
            db_operation_pending := '0';
        elsif rising_edge(fpga_clk_100mhz) then
            -- Iniciar operaci√≥n de switchover de DB
            if lb_switch_pending = '1' and db_operation_pending = '0' then
                db_operation_pending := '1';
                db_switch_delay := (others => '0');
            end if;
            
            -- Ejecutar secuencia de switchover de base de datos
            if db_operation_pending = '1' then
                if db_switch_delay < 5000 then -- 50us delay
                    db_switch_delay := db_switch_delay + 1;
                    
                    -- Primero demote master actual
                    if db_switch_delay < 2000 then
                        db_demote_master <= '1';
                        db_promote_slave <= '0';
                    -- Luego promote nuevo master
                    elsif db_switch_delay < 4000 then
                        db_demote_master <= '0';
                        db_promote_slave <= '1';
                    -- Finalizar operaci√≥n
                    else
                        db_demote_master <= '0';
                        db_promote_slave <= '0';
                    end if;
                else
                    db_operation_pending := '0';
                    db_demote_master <= '0';
                    db_promote_slave <= '0';
                end if;
            end if;
        end if;
    end process;

    -- ================================================
    -- PROCESO: CONTROL DE STORAGE CLUSTER
    -- Gestiona switchover de almacenamiento
    -- ================================================
    process(fpga_clk_100mhz, fpga_reset_n)
    begin
        if fpga_reset_n = '0' then
            storage_switch_primary <= '0';
            storage_sync_required <= '0';
        elsif rising_edge(fpga_clk_100mhz) then
            -- Control de storage primario
            storage_switch_primary <= primary_active_internal;
            
            -- Requerir sincronizaci√≥n en cambio de estado
            storage_sync_required <= lb_switch_pending;
        end if;
    end process;

    -- ================================================
    -- PROCESO: INTERFAZ SNMP
    -- Exposici√≥n de m√©tricas via SNMP
    -- ================================================
    process(fpga_clk_100mhz, fpga_reset_n)
    begin
        if fpga_reset_n = '0' then
            failover_count_reg <= (others => '0');
            snmp_community_string <= x"70756263"; -- "pubc" community
        elsif rising_edge(fpga_clk_100mhz) then
            -- Incrementar contador de failovers
            if snmp_trap_active = '1' then
                failover_count_reg <= failover_count_reg + 1;
            end if;
        end if;
    end process;

    -- ================================================
    -- ASIGNACI√ìN DE SALIDAS SNMP
    -- ================================================
    snmp_oid_availability <= prometheus_data;  -- M√©trica de disponibilidad
    snmp_oid_failover_count <= std_logic_vector(failover_count_reg);
    snmp_trap_critical <= snmp_trap_active;

    -- ================================================
    -- ASIGNACI√ìN DE SALIDAS PRINCIPALES
    -- ================================================
    fpga_failover_trigger <= failover_in_progress;

end network_integration;</pre>
                        </div>
                    </div>
                </div>
                
                <div id="monitoring-integration" class="tab-content">
                    <div class="sla-card">
                        <h3>üìä Integraci√≥n con Stack de Monitoreo</h3>
                        <p>Interfaces nativas para <strong>Prometheus</strong>, <strong>Grafana</strong>, <strong>ELK Stack</strong> y <strong>sistemas SIEM</strong></p>
                        
                        <div class="datacenter-metrics">
                            <h3>üîß M√©tricas Exportadas</h3>
                            <ul>
                                <li><strong>‚è±Ô∏è Uptime total:</strong> Contador en segundos desde √∫ltimo reset</li>
                                <li><strong>üîÑ Failover count:</strong> N√∫mero total de switchovers ejecutados</li>
                                <li><strong>üìä Availability percentage:</strong> % de tiempo en estado operativo</li>
                                <li><strong>‚ö° MTTR actual:</strong> Tiempo promedio de recuperaci√≥n</li>
                                <li><strong>üõ°Ô∏è Health check status:</strong> Estado individual de componentes</li>
                                <li><strong>üåê Network partition events:</strong> Detecciones de split-brain</li>
                                <li><strong>üö® Critical alerts:</strong> Eventos que requieren intervenci√≥n</li>
                                <li><strong>üìà Performance metrics:</strong> Latencia de switchover</li>
                            </ul>
                        </div>

                        <div class="infrastructure-block">
                            <h3>üìã Configuraci√≥n Prometheus/Grafana</h3>
                            <div class="code-block-container">
                                <div class="language-label">YAML - Prometheus Config</div>
                                <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                                <pre class="code-block"># ================================================
# CONFIGURACI√ìN PROMETHEUS PARA FLIP FLOP D HA
# Scraping de m√©tricas del controlador failover
# ================================================

global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "flipflop_ha_rules.yml"

scrape_configs:
  - job_name: 'flipflop-ha-controller'
    static_configs:
      - targets: ['fpga-ha-01:9100', 'fpga-ha-02:9100']
    scrape_interval: 5s
    scrape_timeout: 3s
    metrics_path: /metrics
    params:
      format: ['prometheus']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
      - source_labels: [__address__]
        regex: '([^:]+):(.*)'
        target_label: datacenter
        replacement: 'dc-primary'

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

---
# ================================================
# ALERTING RULES PARA FLIP FLOP D HA
# Archivo: flipflop_ha_rules.yml
# ================================================

groups:
- name: flipflop_ha_alerts
  rules:
  
  # Alert para failover frequency alta
  - alert: HighFailoverRate
    expr: increase(flipflop_failover_count_total[1h]) > 5
    for: 5m
    labels:
      severity: warning
      service: high_availability
      component: flipflop_controller
    annotations:
      summary: "High failover rate detected"
      description: "More than 5 failovers in the last hour on {{ $labels.instance }}"
      runbook_url: "https://wiki.company.com/runbooks/ha-flipflop-high-failover"
  
  # Alert para sistema en estado no operativo
  - alert: SystemNotOperational
    expr: flipflop_system_health_ok == 0
    for: 30s
    labels:
      severity: critical
      service: high_availability  
      component: flipflop_controller
    annotations:
      summary: "HA system not operational"
      description: "Flip flop HA controller reports system not healthy on {{ $labels.instance }}"
      runbook_url: "https://wiki.company.com/runbooks/ha-flipflop-not-operational"
  
  # Alert para split-brain detectado
  - alert: SplitBrainDetected
    expr: flipflop_split_brain_events_total > 0
    for: 0s
    labels:
      severity: critical
      service: high_availability
      component: flipflop_controller
    annotations:
      summary: "Split-brain condition detected"
      description: "Network partition causing split-brain on {{ $labels.instance }}"
      runbook_url: "https://wiki.company.com/runbooks/ha-flipflop-split-brain"
  
  # Alert para availability SLA breach
  - alert: AvailabilityBelowSLA
    expr: flipflop_availability_percentage < 99.99
    for: 5m
    labels:
      severity: warning
      service: high_availability
      component: flipflop_controller
    annotations:
      summary: "Availability below SLA threshold"
      description: "Current availability {{ $value }}% is below 99.99% SLA on {{ $labels.instance }}"
      runbook_url: "https://wiki.company.com/runbooks/ha-flipflop-sla-breach"

  # Alert para uptime bajo (indicador de reinicios frecuentes)
  - alert: LowUptime
    expr: flipflop_uptime_seconds < 3600
    for: 2m
    labels:
      severity: warning
      service: high_availability
      component: flipflop_controller
    annotations:
      summary: "Low uptime detected"
      description: "System uptime {{ $value }} seconds indicates recent restart on {{ $labels.instance }}"
      runbook_url: "https://wiki.company.com/runbooks/ha-flipflop-low-uptime"

---
# ================================================
# GRAFANA DASHBOARD CONFIGURATION
# Archivo: grafana_dashboard_ha_flipflop.json
# ================================================

{
  "dashboard": {
    "id": null,
    "title": "FLIP FLOP D - High Availability Controller",
    "tags": ["ha", "failover", "fpga", "datacenter"],
    "timezone": "UTC",
    "refresh": "5s",
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "panels": [
      {
        "id": 1,
        "title": "System Health Status",
        "type": "stat",
        "targets": [
          {
            "expr": "flipflop_system_health_ok",
            "legendFormat": "System Health"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "min": 99.9,
            "max": 100,
            "thresholds": {
              "steps": [
                {"color": "red", "value": 99.9},
                {"color": "yellow", "value": 99.95},
                {"color": "green", "value": 99.99}
              ]
            }
          }
        }
      },
      {
        "id": 5,
        "title": "MTTR Trend",
        "type": "graph",
        "targets": [
          {
            "expr": "flipflop_mttr_seconds",
            "legendFormat": "Mean Time To Recovery (seconds)"
          }
        ]
      },
      {
        "id": 6,
        "title": "Uptime",
        "type": "stat",
        "targets": [
          {
            "expr": "flipflop_uptime_seconds / 86400",
            "legendFormat": "Uptime (days)"
          }
        ]
      }
    ]
  }
}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Slide 4: Testing y Validaci√≥n de Disponibilidad -->
            <div class="slide">
                <h2>üß™ TESTING Y VALIDACI√ìN DE DISPONIBILIDAD</h2>
                
                <div class="infrastructure-block">
                    <h3>üî¨ Testbench con Scenarios de Falla Reales</h3>
                    <p>Simulaci√≥n completa de <strong>disaster recovery</strong>, <strong>chaos engineering</strong> y <strong>network partitions</strong> para validar robustez del sistema</p>
                </div>

                <div class="tab-container">
                    <button class="tab-button active" onclick="showTab('testbench-ha')">Testbench HA</button>
                    <button class="tab-button" onclick="showTab('chaos-engineering')">Chaos Engineering</button>
                    <button class="tab-button" onclick="showTab('disaster-recovery')">Disaster Recovery</button>
                </div>
                
                <div id="testbench-ha" class="tab-content active">
                    <div class="availability-card">
                        <h3>üìù Archivo: tb_flipflop_ha_validation.vhd</h3>
                        <p>Testbench que simula condiciones cr√≠ticas de un centro de datos real incluyendo fault injection</p>
                        
                        <div class="code-block-container">
                            <div class="language-label">VHDL - HA Testbench</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block">-- ================================================
-- TESTBENCH PARA VALIDACI√ìN DE ALTA DISPONIBILIDAD
-- Simula disaster scenarios en centros de datos
-- Incluye: chaos engineering, network partitions, split-brain
-- ================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;
use ieee.std_logic_textio.all;

entity tb_flipflop_ha_validation is
end tb_flipflop_ha_validation;

architecture test_high_availability of tb_flipflop_ha_validation is
    
    -- ================================================
    -- COMPONENTE BAJO PRUEBA (DUT)
    -- ================================================
    component flipflop_d_failover_ha is
        generic (
            HEARTBEAT_TIMEOUT_MS    : positive := 5000;
            FAILOVER_DELAY_MS       : positive := 1000;
            HEALTH_CHECK_PERIOD_MS  : positive := 100;
            SPLIT_BRAIN_DETECT_MS   : positive := 2000;
            ENABLE_MONITORING       : boolean  := true;
            ENABLE_LOGGING          : boolean  := true
        );
        port (
            clk_datacenter         : in  std_logic;
            heartbeat_cluster      : in  std_logic;
            reset_emergency        : in  std_logic;
            server_health_primary  : in  std_logic;
            server_health_secondary: in  std_logic;
            network_connectivity   : in  std_logic;
            maintenance_mode       : in  std_logic;
            load_balancer_status   : in  std_logic;
            database_sync_ok       : in  std_logic;
            storage_cluster_ok     : in  std_logic;
            primary_server_active  : out std_logic;
            secondary_server_active: out std_logic;
            failover_in_progress   : out std_logic;
            system_health_ok       : out std_logic;
            snmp_trap_trigger      : out std_logic;
            syslog_event_trigger   : out std_logic;
            prometheus_metrics     : out std_logic_vector(7 downto 0);
            ha_state_debug         : out std_logic_vector(3 downto 0);
            last_failover_cause    : out std_logic_vector(3 downto 0);
            uptime_counter         : out std_logic_vector(31 downto 0)
        );
    end component;
    
    -- ================================================
    -- SE√ëALES DE PRUEBA
    -- ================================================
    signal clk_100mhz               : std_logic := '0';
    signal heartbeat_1hz            : std_logic := '0';
    signal reset_n                  : std_logic := '1';
    signal primary_health           : std_logic := '1';
    signal secondary_health         : std_logic := '1';
    signal network_ok               : std_logic := '1';
    signal maintenance              : std_logic := '0';
    signal lb_status                : std_logic := '1';
    signal db_sync                  : std_logic := '1';
    signal storage_ok               : std_logic := '1';
    
    -- Salidas
    signal primary_active           : std_logic;
    signal secondary_active         : std_logic;
    signal failover_active          : std_logic;
    signal system_healthy           : std_logic;
    signal snmp_trap                : std_logic;
    signal syslog_event            : std_logic;
    signal metrics                  : std_logic_vector(7 downto 0);
    signal ha_state                 : std_logic_vector(3 downto 0);
    signal failover_cause           : std_logic_vector(3 downto 0);
    signal uptime                   : std_logic_vector(31 downto 0);
    
    -- ================================================
    -- SE√ëALES PARA CHAOS ENGINEERING
    -- ================================================
    signal chaos_primary_failure    : std_logic := '0';
    signal chaos_secondary_failure  : std_logic := '0';
    signal chaos_network_partition  : std_logic := '0';
    signal chaos_storage_failure    : std_logic := '0';
    signal chaos_db_desync         : std_logic := '0';
    
    -- ================================================
    -- CONTADORES Y M√âTRICAS DE TEST
    -- ================================================
    signal test_phase              : integer := 0;
    signal failover_count          : integer := 0;
    signal total_downtime_ms       : integer := 0;
    signal sla_violations          : integer := 0;
    
    -- ================================================
    -- CONSTANTES DE TIEMPO PARA SIMULACI√ìN
    -- ================================================
    constant CLK_100MHZ_PERIOD     : time := 10 ns;     -- 100MHz sistema
    constant HEARTBEAT_PERIOD      : time := 1 sec;     -- 1Hz heartbeat
    constant FAILOVER_TIMEOUT      : time := 5 sec;     -- 5 seg m√°ximo failover
    constant SPLIT_BRAIN_TIMEOUT   : time := 2 sec;     -- 2 seg split-brain
    constant SLA_DOWNTIME_MAX      : time := 5.256 min; -- 99.99% anual = 52.6min
    
    -- ================================================
    -- PROCEDIMIENTOS PARA DISASTER SCENARIOS
    -- ================================================
    procedure simulate_server_crash(signal health : out std_logic;
                                   server_name : string;
                                   crash_duration : time) is
    begin
        report "üí• SIMULATING SERVER CRASH: " & server_name;
        health <= '0';
        wait for crash_duration;
        report "üîÑ SERVER RECOVERY: " & server_name;
        health <= '1';
    end procedure;
    
    procedure simulate_network_partition(signal network : out std_logic;
                                       partition_duration : time) is
    begin
        report "üåê SIMULATING NETWORK PARTITION";
        network <= '0';
        wait for partition_duration;
        report "‚úÖ NETWORK RESTORED";
        network <= '1';
    end procedure;
    
    procedure simulate_storage_outage(signal storage : out std_logic;
                                     outage_duration : time) is
    begin
        report "üíæ SIMULATING STORAGE OUTAGE";
        storage <= '0';
        wait for outage_duration;
        report "üíæ STORAGE RESTORED";
        storage <= '1';
    end procedure;
    
    procedure validate_sla_compliance(signal downtime_start : std_logic;
                                     signal downtime_end : std_logic;
                                     max_downtime : time) is
        variable actual_downtime : time;
    begin
        if downtime_start = '1' then
            actual_downtime := now;
            wait until downtime_end = '1';
            actual_downtime := now - actual_downtime;
            
            if actual_downtime > max_downtime then
                report "‚ùå SLA VIOLATION: Downtime " & time'image(actual_downtime) & 
                       " exceeds maximum " & time'image(max_downtime) severity error;
                sla_violations <= sla_violations + 1;
            else
                report "‚úÖ SLA COMPLIANT: Downtime " & time'image(actual_downtime) & 
                       " within limits" severity note;
            end if;
        end if;
    end procedure;

begin

    -- ================================================
    -- GENERACI√ìN DE RELOJES
    -- ================================================
    
    -- Reloj sistema 100MHz
    clk_100mhz <= not clk_100mhz after CLK_100MHZ_PERIOD/2;
    
    -- Heartbeat cluster 1Hz
    heartbeat_1hz <= not heartbeat_1hz after HEARTBEAT_PERIOD/2;

    -- ================================================
    -- INSTANCIACI√ìN DEL DUT
    -- ================================================
    dut: flipflop_d_failover_ha
        generic map (
            HEARTBEAT_TIMEOUT_MS    => 100,    -- Reducido para simulaci√≥n
            FAILOVER_DELAY_MS       => 50,     -- Reducido para simulaci√≥n
            HEALTH_CHECK_PERIOD_MS  => 10,     -- Reducido para simulaci√≥n
            SPLIT_BRAIN_DETECT_MS   => 100,    -- Reducido para simulaci√≥n
            ENABLE_MONITORING       => true,
            ENABLE_LOGGING          => true
        )
        port map (
            clk_datacenter         => clk_100mhz,
            heartbeat_cluster      => heartbeat_1hz,
            reset_emergency        => reset_n,
            server_health_primary  => primary_health and not chaos_primary_failure,
            server_health_secondary=> secondary_health and not chaos_secondary_failure,
            network_connectivity   => network_ok and not chaos_network_partition,
            maintenance_mode       => maintenance,
            load_balancer_status   => lb_status,
            database_sync_ok       => db_sync and not chaos_db_desync,
            storage_cluster_ok     => storage_ok and not chaos_storage_failure,
            primary_server_active  => primary_active,
            secondary_server_active=> secondary_active,
            failover_in_progress   => failover_active,
            system_health_ok       => system_healthy,
            snmp_trap_trigger      => snmp_trap,
            syslog_event_trigger   => syslog_event,
            prometheus_metrics     => metrics,
            ha_state_debug         => ha_state,
            last_failover_cause    => failover_cause,
            uptime_counter         => uptime
        );

    -- ================================================
    -- PROCESO PRINCIPAL DE SIMULACI√ìN HA
    -- ================================================
    process
        variable test_start_time : time;
        variable scenario_start_time : time;
        variable total_failovers : integer := 0;
        variable disaster_count : integer := 0;
        
    begin
        -- ================================================
        -- FASE 1: INICIALIZACI√ìN DEL SISTEMA HA
        -- ================================================
        report "üè¢ INICIANDO SIMULACI√ìN DE DATA CENTER HA";
        report "üìã Validaci√≥n basada en scenarios de producci√≥n real";
        test_start_time := now;
        test_phase <= 1;
        
        -- Reset inicial del sistema
        reset_n <= '0';
        primary_health <= '1';
        secondary_health <= '1';
        network_ok <= '1';
        maintenance <= '0';
        lb_status <= '1';
        db_sync <= '1';
        storage_ok <= '1';
        
        wait for 100 ms;  -- Reset period
        reset_n <= '1';
        wait for 50 ms;   -- Stabilization
        
        report "‚úÖ SISTEMA HA INICIALIZADO - Data center operativo";
        wait for 500 ms;  -- Initial startup time

        -- ================================================
        -- FASE 2: OPERACI√ìN NORMAL - BASELINE ESTABLISHMENT
        -- ================================================
        test_phase <= 2;
        report "üìä FASE 2: ESTABLECIENDO BASELINE DE OPERACI√ìN NORMAL";
        
        -- Verificar estado inicial
        wait for 200 ms;
        assert primary_active = '1' report "‚ùå ERROR: Primario no activo en baseline" severity error;
        assert secondary_active = '0' report "‚ùå ERROR: Secundario activo en baseline" severity error;
        assert system_healthy = '1' report "‚ùå ERROR: Sistema no healthy en baseline" severity error;
        
        report "‚úÖ BASELINE ESTABLECIDO: Sistema operando normalmente";
        wait for 1 sec; -- Baseline period

        -- ================================================
        -- FASE 3: DISASTER SCENARIOS - CHAOS ENGINEERING
        -- ================================================
        test_phase <= 3;
        report "üí• FASE 3: CHAOS ENGINEERING - DISASTER SCENARIOS";
        
        -- Scenario 1: Primary server crash
        disaster_count := disaster_count + 1;
        scenario_start_time := now;
        report "üî• SCENARIO 1: Primary server crash simulation";
        
        chaos_primary_failure <= '1';
        wait for 10 ms; -- Detection time
        
        -- Verificar failover autom√°tico
        wait until failover_active = '1' for 200 ms;
        assert failover_active = '1' report "‚ùå ERROR: Failover no iniciado" severity error;
        
        wait until secondary_active = '1' for 2 sec;
        assert secondary_active = '1' report "‚ùå ERROR: Failover a secundario fall√≥" severity error;
        assert primary_active = '0' report "‚ùå ERROR: Primario no desactivado" severity error;
        
        total_failovers := total_failovers + 1;
        report "‚úÖ SCENARIO 1 COMPLETADO: Failover exitoso en " & 
               time'image(now - scenario_start_time);
        
        -- Recuperar primario
        wait for 500 ms;
        chaos_primary_failure <= '0';
        wait for 1 sec;

        -- Scenario 2: Network partition (split-brain)
        disaster_count := disaster_count + 1;
        scenario_start_time := now;
        report "üåê SCENARIO 2: Network partition simulation";
        
        chaos_network_partition <= '1';
        wait for 10 ms;
        
        -- Verificar detecci√≥n de split-brain
        wait for 300 ms; -- Split-brain detection timeout
        
        report "‚úÖ SCENARIO 2 COMPLETADO: Split-brain manejado";
        chaos_network_partition <= '0';
        wait for 1 sec;

        -- Scenario 3: Database desynchronization
        disaster_count := disaster_count + 1;
        scenario_start_time := now;
        report "üíæ SCENARIO 3: Database desync simulation";
        
        chaos_db_desync <= '1';
        wait for 10 ms;
        
        -- Verificar protecci√≥n contra desync
        wait until failover_active = '1' for 500 ms;
        if failover_active = '1' then
            total_failovers := total_failovers + 1;
            report "‚úÖ SCENARIO 3: Failover por DB desync";
        end if;
        
        chaos_db_desync <= '0';
        wait for 1 sec;

        -- Scenario 4: Storage cluster failure
        disaster_count := disaster_count + 1;
        scenario_start_time := now;
        report "üíΩ SCENARIO 4: Storage cluster failure";
        
        chaos_storage_failure <= '1';
        wait for 10 ms;
        
        wait until failover_active = '1' for 500 ms;
        if failover_active = '1' then
            total_failovers := total_failovers + 1;
            report "‚úÖ SCENARIO 4: Failover por storage failure";
        end if;
        
        chaos_storage_failure <= '0';
        wait for 1 sec;

        -- Scenario 5: Cascading failures (worst case)
        disaster_count := disaster_count + 1;
        scenario_start_time := now;
        report "‚ö° SCENARIO 5: Cascading failures simulation";
        
        -- Fallo simult√°neo de m√∫ltiples componentes
        chaos_primary_failure <= '1';
        wait for 50 ms;
        chaos_network_partition <= '1';
        wait for 50 ms;
        chaos_storage_failure <= '1';
        
        -- Verificar respuesta del sistema
        wait for 1 sec;
        
        -- Recuperaci√≥n gradual
        chaos_storage_failure <= '0';
        wait for 200 ms;
        chaos_network_partition <= '0';
        wait for 200 ms;
        chaos_primary_failure <= '0';
        
        report "‚úÖ SCENARIO 5 COMPLETADO: Cascading failure recovery";
        wait for 2 sec;

        -- ================================================
        -- FASE 4: MAINTENANCE WINDOW TESTING
        -- ================================================
        test_phase <= 4;
        report "üîß FASE 4: MAINTENANCE WINDOW VALIDATION";
        
        -- Activar modo mantenimiento
        maintenance <= '1';
        wait for 100 ms;
        
        -- Verificar que no hay failovers durante mantenimiento
        chaos_primary_failure <= '1';
        wait for 500 ms;
        
        -- Sistema debe mantener estado durante mantenimiento
        assert failover_active = '0' report "‚ùå ERROR: Failover durante mantenimiento" severity error;
        
        maintenance <= '0';
        chaos_primary_failure <= '0';
        wait for 500 ms;

        -- ================================================
        -- FASE 5: LOAD TESTING Y STRESS
        -- ================================================
        test_phase <= 5;
        report "üí™ FASE 5: LOAD TESTING Y STRESS SCENARIOS";
        
        -- Rapid failovers para stress testing
        for i in 1 to 10 loop
            chaos_primary_failure <= '1';
            wait for 100 ms;
            chaos_primary_failure <= '0';
            wait for 200 ms;
            chaos_secondary_failure <= '1';
            wait for 100 ms;
            chaos_secondary_failure <= '0';
            wait for 200 ms;
            total_failovers := total_failovers + 2;
        end loop;
        
        report "üí™ STRESS TEST COMPLETADO: 20 failovers r√°pidos";

        -- ================================================
        -- FASE 6: SLA COMPLIANCE VALIDATION
        -- ================================================
        test_phase <= 6;
        report "üìä FASE 6: VALIDACI√ìN DE CUMPLIMIENTO SLA";
        
        -- Verificar m√©tricas de SLA
        wait for 100 ms;
        
        report "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê";
        report "üè¢ REPORTE DE VALIDACI√ìN DATA CENTER HA";
        report "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê";
        report "‚è∞ Tiempo total simulaci√≥n: " & time'image(now - test_start_time);
        report "üîÑ Total failovers ejecutados: " & integer'image(total_failovers);
        report "üí• Disaster scenarios probados: " & integer'image(disaster_count);
        report "üìä Violaciones SLA detectadas: " & integer'image(sla_violations);
        report "‚úÖ Sistema aprobado para producci√≥n: " & 
               (if sla_violations = 0 then "S√ç" else "NO");
        report "üìã Cumple 99.99% availability: " & 
               (if sla_violations = 0 then "S√ç" else "NO");
        report "üõ°Ô∏è Chaos engineering passed: S√ç";
        report "‚ö° Failover autom√°tico funcional: S√ç";
        report "üîß Maintenance mode validado: S√ç";
        report "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê";
        
        -- Final de simulaci√≥n
        report "üéâ VALIDACI√ìN HA COMPLETADA EXITOSAMENTE";
        wait;
        
    end process;

    -- ================================================
    -- PROCESO DE MONITOREO CONTINUO DE M√âTRICAS
    -- ================================================
    process(clk_100mhz)
        variable uptime_prev : std_logic_vector(31 downto 0) := (others => '0');
        variable availability_calc : real := 0.0;
    begin
        if rising_edge(clk_100mhz) then
            -- Monitor de failovers
            if failover_active = '1' and failover_active'event then
                failover_count <= failover_count + 1;
                report "üîÑ FAILOVER #" & integer'image(failover_count) & 
                       " detectado en T=" & time'image(now);
            end if;
            
            -- Monitor de SNMP traps
            if snmp_trap = '1' and snmp_trap'event then
                report "üì° SNMP TRAP generado - Causa: " & 
                       integer'image(to_integer(unsigned(failover_cause)));
            end if;
            
            -- Monitor de syslog events
            if syslog_event = '1' and syslog_event'event then
                report "üìù SYSLOG EVENT generado - Estado: " & 
                       integer'image(to_integer(unsigned(ha_state)));
            end if;
            
            -- Calcular availability en tiempo real
            if uptime /= uptime_prev then
                uptime_prev := uptime;
                availability_calc := (real(to_integer(unsigned(metrics))) / 255.0) * 100.0;
                
                if availability_calc < 99.99 then
                    report "‚ö†Ô∏è WARNING: Availability " & real'image(availability_calc) & 
                           "% below SLA threshold" severity warning;
                end if;
            end if;
        end if;
    end process;

    -- ================================================
    -- PROCESO DE VALIDACI√ìN AUTOM√ÅTICA
    -- ================================================
    process
    begin
        -- Validaciones continuas durante la simulaci√≥n
        loop
            wait for 1 sec;
            
            -- Verificar que sistema responde a health checks
            if system_healthy = '0' and test_phase > 1 and test_phase < 6 then
                report "üö® CRITICAL: Sistema reporta unhealthy" severity warning;
            end if;
            
            -- Verificar que solo un servidor est√° activo
            if primary_active = '1' and secondary_active = '1' then
                report "‚ùå FATAL: Split-brain - ambos servidores activos" severity error;
            end if;
            
            -- Verificar que al menos un servidor est√° activo (excepto en disaster)
            if primary_active = '0' and secondary_active = '0' and test_phase /= 3 then
                report "‚ùå CRITICAL: Ning√∫n servidor activo" severity error;
            end if;
        end loop;
    end process;

end test_high_availability;</pre>
                        </div>
                    </div>
                </div>
                
                <div id="chaos-engineering" class="tab-content">
                    <div class="sla-card">
                        <h3>üí• Chaos Engineering para Data Centers</h3>
                        <p>Metodolog√≠a para validar <strong>fault tolerance</strong> mediante inyecci√≥n controlada de fallos</p>
                        
                        <div class="monitoring-card">
                            <h3>üî¨ Chaos Experiments Sistem√°ticos</h3>
                            <div class="steps-grid">
                                <div class="step-card">
                                    <div class="step-number">1</div>
                                    <h4>SERVER FAILURES</h4>
                                    <p><strong>Hip√≥tesis:</strong> Sistema sobrevive falla primario</p>
                                    <ul>
                                        <li>Primary crash inesperado</li>
                                        <li>Secondary crash durante failover</li>
                                        <li>Boot loop scenarios</li>
                                        <li>Memory exhaustion</li>
                                    </ul>
                                </div>
                                
                                <div class="step-card">
                                    <div class="step-number">2</div>
                                    <h4>NETWORK PARTITIONS</h4>
                                    <p><strong>Hip√≥tesis:</strong> Split-brain detectado y manejado</p>
                                    <ul>
                                        <li>Complete network isolation</li>
                                        <li>Intermittent connectivity</li>
                                        <li>High latency scenarios</li>
                                        <li>Packet loss simulation</li>
                                    </ul>
                                </div>
                                
                                <div class="step-card">
                                    <div class="step-number">3</div>
                                    <h4>STORAGE OUTAGES</h4>
                                    <p><strong>Hip√≥tesis:</strong> Failover preserva datos</p>
                                    <ul>
                                        <li>SAN/NAS disconnection</li>
                                        <li>Disk full scenarios</li>
                                        <li>Corruption detection</li>
                                        <li>Sync lag overflow</li>
                                    </ul>
                                </div>
                                
                                <div class="step-card">
                                    <div class="step-number">4</div>
                                    <h4>CASCADING FAILURES</h4>
                                    <p><strong>Hip√≥tesis:</strong> Sistema degrada gracefully</p>
                                    <ul>
                                        <li>Multiple component failures</li>
                                        <li>Resource exhaustion</li>
                                        <li>Dependency failures</li>
                                        <li>Recovery stress testing</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <div class="infrastructure-block">
                            <h3>üõ†Ô∏è Herramientas de Chaos Engineering</h3>
                            <div class="code-block-container">
                                <div class="language-label">Chaos Toolkit Config</div>
                                <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                                <pre class="code-block"># ================================================
# CHAOS ENGINEERING CONFIGURATION
# Para validaci√≥n autom√°tica de resiliencia
# ================================================

# chaos_experiments.yaml
version: 1.0.0
title: "FLIP FLOP D HA - Chaos Engineering Suite"
description: "Validation of high availability system resilience"

configuration:
  flipflop_ha_endpoint: "http://fpga-ha-controller:8080"
  monitoring_endpoint: "http://prometheus:9090"
  alertmanager_endpoint: "http://alertmanager:9093"

steady-state-hypothesis:
  title: "System is healthy and responsive"
  probes:
    - name: "primary-or-secondary-active"
      type: "probe"
      provider:
        type: "http"
        url: "${flipflop_ha_endpoint}/health"
        method: "GET"
        timeout: 5
      tolerance:
        type: "jsonpath"
        path: "$.system_healthy"
        expect: true
    
    - name: "no-split-brain-condition"
      type: "probe"
      provider:
        type: "http"
        url: "${flipflop_ha_endpoint}/status"
        method: "GET"
      tolerance:
        type: "jsonpath"
        path: "$.split_brain_detected"
        expect: false

experiments:
  # Experiment 1: Primary server failure
  - title: "Primary Server Crash"
    description: "Simulate primary server crash and validate failover"
    method:
      - name: "crash-primary-server"
        type: "action"
        provider:
          type: "process"
          path: "pkill"
          arguments: ["-f", "primary-server"]
      
      - name: "wait-for-failover"
        type: "probe"
        provider:
          type: "http"
          url: "${flipflop_ha_endpoint}/status"
          method: "GET"
        tolerance:
          type: "jsonpath"
          path: "$.secondary_active"
          expect: true
        probe_timeout: 30
    
    rollbacks:
      - name: "restart-primary-server"
        type: "action"
        provider:
          type: "process"
          path: "systemctl"
          arguments: ["start", "primary-server"]

  # Experiment 2: Network partition
  - title: "Network Partition"
    description: "Simulate network split between servers"
    method:
      - name: "block-network-traffic"
        type: "action"
        provider:
          type: "process"
          path: "iptables"
          arguments: ["-A", "INPUT", "-s", "10.0.1.0/24", "-j", "DROP"]
      
      - name: "validate-split-brain-detection"
        type: "probe"
        provider:
          type: "http"
          url: "${flipflop_ha_endpoint}/status"
          method: "GET"
        tolerance:
          type: "jsonpath"
          path: "$.ha_state"
          expect: "HA_SPLIT_BRAIN"
        probe_timeout: 10
    
    rollbacks:
      - name: "restore-network"
        type: "action"
        provider:
          type: "process"
          path: "iptables"
          arguments: ["-D", "INPUT", "-s", "10.0.1.0/24", "-j", "DROP"]

  # Experiment 3: Database synchronization failure
  - title: "Database Sync Failure"
    description: "Simulate database replication lag"
    method:
      - name: "stop-database-replication"
        type: "action"
        provider:
          type: "process"
          path: "mysql"
          arguments: ["-e", "STOP SLAVE;"]
      
      - name: "validate-db-failover"
        type: "probe"
        provider:
          type: "http"
          url: "${flipflop_ha_endpoint}/status"
          method: "GET"
        tolerance:
          type: "jsonpath"
          path: "$.database_sync_ok"
          expect: false
    
    rollbacks:
      - name: "restart-replication"
        type: "action"
        provider:
          type: "process"
          path: "mysql"
          arguments: ["-e", "START SLAVE;"]

  # Experiment 4: Load balancer failure
  - title: "Load Balancer Outage"
    description: "Simulate F5/HAProxy failure"
    method:
      - name: "stop-load-balancer"
        type: "action"
        provider:
          type: "process"
          path: "systemctl"
          arguments: ["stop", "haproxy"]
      
      - name: "validate-lb-detection"
        type: "probe"
        provider:
          type: "http"
          url: "${flipflop_ha_endpoint}/status"
          method: "GET"
        tolerance:
          type: "jsonpath"
          path: "$.load_balancer_status"
          expect: false
    
    rollbacks:
      - name: "restart-load-balancer"
        type: "action"
        provider:
          type: "process"
          path: "systemctl"
          arguments: ["start", "haproxy"]

# ================================================
# AUTOMATED CHAOS TESTING PIPELINE
# CI/CD integration script
# ================================================

# chaos_pipeline.py
import subprocess
import json
import time
import requests
from datetime import datetime

class ChaosTestSuite:
    def __init__(self, config_file="chaos_experiments.yaml"):
        self.config_file = config_file
        self.results = []
        
    def run_experiment(self, experiment_name):
        """Execute a single chaos experiment"""
        print(f"üî• Executing chaos experiment: {experiment_name}")
        
        start_time = datetime.now()
        
        # Run chaos toolkit experiment
        cmd = f"chaos run {self.config_file} --experiment={experiment_name}"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        experiment_result = {
            "name": experiment_name,
            "start_time": start_time.isoformat(),
            "duration_seconds": duration,
            "success": result.returncode == 0,
            "output": result.stdout,
            "error": result.stderr if result.stderr else None
        }
        
        self.results.append(experiment_result)
        
        if experiment_result["success"]:
            print(f"‚úÖ Experiment {experiment_name} completed successfully")
        else:
            print(f"‚ùå Experiment {experiment_name} failed")
            print(f"Error: {experiment_result['error']}")
        
        return experiment_result
    
    def run_full_suite(self):
        """Execute complete chaos engineering suite"""
        experiments = [
            "Primary Server Crash",
            "Network Partition", 
            "Database Sync Failure",
            "Load Balancer Outage"
        ]
        
        print("üöÄ Starting Chaos Engineering Test Suite")
        print(f"üìÖ Started at: {datetime.now().isoformat()}")
        
        for experiment in experiments:
            self.run_experiment(experiment)
            time.sleep(30)  # Wait between experiments
        
        self.generate_report()
    
    def generate_report(self):
        """Generate chaos engineering report"""
        total_experiments = len(self.results)
        successful_experiments = sum(1 for r in self.results if r["success"])
        
        print("\n" + "="*60)
        print("üéØ CHAOS ENGINEERING REPORT")
        print("="*60)
        print(f"üìä Total experiments: {total_experiments}")
        print(f"‚úÖ Successful: {successful_experiments}")
        print(f"‚ùå Failed: {total_experiments - successful_experiments}")
        print(f"üìà Success rate: {(successful_experiments/total_experiments)*100:.1f}%")
        
        for result in self.results:
            status = "‚úÖ" if result["success"] else "‚ùå"
            print(f"{status} {result['name']}: {result['duration_seconds']:.1f}s")
        
        # Save detailed report
        with open("chaos_report.json", "w") as f:
            json.dump(self.results, f, indent=2)
        
        print(f"\nüìÑ Detailed report saved to: chaos_report.json")

if __name__ == "__main__":
    chaos_suite = ChaosTestSuite()
    chaos_suite.run_full_suite()</pre>
                        </div>
                    </div>
                </div>
                
                <div id="disaster-recovery" class="tab-content">
                    <div class="datacenter-metrics">
                        <h3>üö® Procedimientos de Disaster Recovery</h3>
                        <p>Protocolos validados para <strong>recuperaci√≥n ante desastres</strong> y <strong>business continuity</strong></p>
                        
                        <div class="availability-card">
                            <h3>üìã DR Testing Matrix</h3>
                            
                            <table class="pin-table">
                                <thead>
                                    <tr>
                                        <th>Scenario</th>
                                        <th>RTO Target</th>
                                        <th>RPO Target</th>
                                        <th>Test Frequency</th>
                                        <th>Success Criteria</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Single Server Failure</td>
                                        <td><5 minutes</td>
                                        <td><1 minute</td>
                                        <td>Weekly</td>
                                        <td>Automatic failover, no data loss</td>
                                    </tr>
                                    <tr>
                                        <td>Data Center Outage</td>
                                        <td><30 minutes</td>
                                        <td><5 minutes</td>
                                        <td>Monthly</td>
                                        <td>DR site activation, <5min data loss</td>
                                    </tr>
                                    <tr>
                                        <td>Network Partition</td>
                                        <td><2 minutes</td>
                                        <td>0 seconds</td>
                                        <td>Bi-weekly</td>
                                        <td>Split-brain prevention, data consistency</td>
                                    </tr>
                                    <tr>
                                        <td>Storage Corruption</td>
                                        <td><15 minutes</td>
                                        <td><1 hour</td>
                                        <td>Quarterly</td>
                                        <td>Backup restoration, integrity validation</td>
                                    </tr>
                                    <tr>
                                        <td>Complete Infrastructure Loss</td>
                                        <td><4 hours</td>
                                        <td><15 minutes</td>
                                        <td>Semi-annually</td>
                                        <td>Cloud failover, business continuity</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="infrastructure-block">
                            <h3>üîÑ Automated DR Orchestration</h3>
                            <div class="code-block-container">
                                <div class="language-label">Python - DR Automation</div>
                                <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                                <pre class="code-block">#!/usr/bin/env python3
# ================================================
# DISASTER RECOVERY AUTOMATION SCRIPT
# Para orquestaci√≥n autom√°tica de DR procedures
# ================================================

import time
import json
import logging
import requests
import subprocess
from datetime import datetime
from enum import Enum

class DisasterType(Enum):
    SERVER_FAILURE = "server_failure"
    NETWORK_PARTITION = "network_partition"
    DATACENTER_OUTAGE = "datacenter_outage"
    STORAGE_FAILURE = "storage_failure"
    COMPLETE_DISASTER = "complete_disaster"

class DROrchestrator:
    def __init__(self, config_file="dr_config.json"):
        self.config = self.load_config(config_file)
        self.setup_logging()
        
    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('dr_orchestration.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def load_config(self, config_file):
        with open(config_file, 'r') as f:
            return json.load(f)
    
    def detect_disaster(self):
        """Automated disaster detection"""
        try:
            # Check FLIP FLOP D HA controller status
            response = requests.get(
                f"{self.config['ha_endpoint']}/health",
                timeout=5
            )
            
            if response.status_code != 200:
                return DisasterType.SERVER_FAILURE
            
            status = response.json()
            
            # Analyze status for disaster indicators
            if not status.get('system_healthy', False):
                if status.get('split_brain_detected', False):
                    return DisasterType.NETWORK_PARTITION
                elif not status.get('primary_active', False) and not status.get('secondary_active', False):
                    return DisasterType.COMPLETE_DISASTER
                else:
                    return DisasterType.SERVER_FAILURE
            
            return None
            
        except requests.RequestException:
            return DisasterType.DATACENTER_OUTAGE
    
    def execute_dr_procedure(self, disaster_type):
        """Execute appropriate DR procedure based on disaster type"""
        
        self.logger.info(f"üö® DISASTER DETECTED: {disaster_type.value}")
        self.logger.info(f"üîÑ Initiating DR procedure at {datetime.now().isoformat()}")
        
        if disaster_type == DisasterType.SERVER_FAILURE:
            return self.handle_server_failure()
        elif disaster_type == DisasterType.NETWORK_PARTITION:
            return self.handle_network_partition()
        elif disaster_type == DisasterType.DATACENTER_OUTAGE:
            return self.handle_datacenter_outage()
        elif disaster_type == DisasterType.STORAGE_FAILURE:
            return self.handle_storage_failure()
        elif disaster_type == DisasterType.COMPLETE_DISASTER:
            return self.handle_complete_disaster()
    
    def handle_server_failure(self):
        """Handle single server failure"""
        self.logger.info("üñ•Ô∏è Handling server failure...")
        
        # Step 1: Verify failover completed
        if not self.verify_failover_completed():
            self.logger.error("‚ùå Automatic failover failed, initiating manual failover")
            self.trigger_manual_failover()
        
        # Step 2: Validate secondary server health
        if not self.validate_secondary_health():
            self.logger.error("‚ùå Secondary server unhealthy, escalating to datacenter outage")
            return self.handle_datacenter_outage()
        
        # Step 3: Update DNS records
        self.update_dns_records()
        
        # Step 4: Notify stakeholders
        self.send_notifications("Server failover completed successfully")
        
        self.logger.info("‚úÖ Server failure recovery completed")
        return True
    
    def handle_network_partition(self):
        """Handle network partition (split-brain)"""
        self.logger.info("üåê Handling network partition...")
        
        # Step 1: Verify split-brain detection
        if not self.verify_split_brain_protection():
            self.logger.error("‚ùå Split-brain protection failed")
            return False
        
        # Step 2: Isolate network segments
        self.isolate_network_segments()
        
        # Step 3: Designate primary segment
        primary_segment = self.designate_primary_segment()
        
        # Step 4: Shutdown secondary segment safely
        self.shutdown_secondary_segment()
        
        # Step 5: Monitor for network recovery
        self.monitor_network_recovery()
        
        self.logger.info("‚úÖ Network partition handled successfully")
        return True
    
    def handle_datacenter_outage(self):
        """Handle complete datacenter outage"""
        self.logger.info("üè¢ Handling datacenter outage...")
        
        # Step 1: Activate DR site
        if not self.activate_dr_site():
            self.logger.error("‚ùå DR site activation failed")
            return False
        
        # Step 2: Restore from backups
        self.restore_from_backups()
        
        # Step 3: Update external DNS
        self.update_external_dns()
        
        # Step 4: Validate DR site functionality
        if not self.validate_dr_site():
            self.logger.error("‚ùå DR site validation failed")
            return False
        
        # Step 5: Notify customers of potential service impact
        self.notify_customers()
        
        self.logger.info("‚úÖ Datacenter outage recovery completed")
        return True
    
    def verify_failover_completed(self, timeout=300):
        """Verify that automatic failover completed successfully"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                response = requests.get(f"{self.config['ha_endpoint']}/status")
                status = response.json()
                
                if status.get('secondary_active', False) and not status.get('failover_in_progress', True):
                    self.logger.info("‚úÖ Automatic failover completed")
                    return True
                    
            except requests.RequestException:
                pass
            
            time.sleep(5)
        
        self.logger.warning("‚ö†Ô∏è Failover not completed within timeout")
        return False
    
    def trigger_manual_failover(self):
        """Trigger manual failover as last resort"""
        self.logger.info("üîÑ Triggering manual failover...")
        
        try:
            response = requests.post(
                f"{self.config['ha_endpoint']}/manual_failover",
                json={"force": True, "reason": "Automatic failover failed"}
            )
            
            if response.status_code == 200:
                self.logger.info("‚úÖ Manual failover triggered successfully")
                return True
            else:
                self.logger.error(f"‚ùå Manual failover failed: {response.text}")
                return False
                
        except requests.RequestException as e:
            self.logger.error(f"‚ùå Manual failover request failed: {e}")
            return False
    
    def update_dns_records(self):
        """Update DNS records to point to active server"""
        self.logger.info("üåê Updating DNS records...")
        
        # Implementation depends on DNS provider (Route53, CloudFlare, etc.)
        # This is a placeholder for the actual DNS update logic
        
        dns_updates = [
            {"record": "app.company.com", "type": "A", "value": self.config['secondary_ip']},
            {"record": "api.company.com", "type": "A", "value": self.config['secondary_ip']}
        ]
        
        for update in dns_updates:
            self.logger.info(f"Updating {update['record']} to {update['value']}")
            # Actual DNS API call would go here
        
        self.logger.info("‚úÖ DNS records updated")
    
    def send_notifications(self, message):
        """Send notifications to stakeholders"""
        notifications = [
            {"type": "slack", "webhook": self.config['slack_webhook'], "message": message},
            {"type": "email", "recipients": self.config['email_recipients'], "message": message},
            {"type": "pagerduty", "service_key": self.config['pagerduty_key'], "message": message}
        ]
        
        for notification in notifications:
            try:
                if notification['type'] == 'slack':
                    requests.post(notification['webhook'], json={"text": message})
                # Add other notification implementations
                
                self.logger.info(f"‚úÖ Notification sent via {notification['type']}")
            except Exception as e:
                self.logger.error(f"‚ùå Failed to send {notification['type']} notification: {e}")
    
    def run_continuous_monitoring(self):
        """Continuous monitoring loop for disaster detection"""
        self.logger.info("üîç Starting continuous disaster monitoring...")
        
        while True:
            try:
                disaster_type = self.detect_disaster()
                
                if disaster_type:
                    self.logger.warning(f"üö® Disaster detected: {disaster_type.value}")
                    success = self.execute_dr_procedure(disaster_type)
                    
                    if success:
                        self.logger.info("‚úÖ DR procedure completed successfully")
                    else:
                        self.logger.error("‚ùå DR procedure failed, manual intervention required")
                        self.escalate_to_humans()
                
                time.sleep(30)  # Check every 30 seconds
                
            except KeyboardInterrupt:
                self.logger.info("üëã Monitoring stopped by user")
                break
            except Exception as e:
                self.logger.error(f"‚ùå Error in monitoring loop: {e}")
                time.sleep(60)  # Wait longer on error

def main():
    """Main entry point for DR orchestration"""
    dr_orchestrator = DROrchestrator()
    
    # Run continuous monitoring
    dr_orchestrator.run_continuous_monitoring()

if __name__ == "__main__":
    main()</pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: Implementaci√≥n y Monitoreo -->
        <div class="slide">
            <h2>‚öôÔ∏è IMPLEMENTACI√ìN Y MONITOREO</h2>
            
            <div class="infrastructure-block">
                <h3>üîß S√≠ntesis con Consideraciones de Confiabilidad</h3>
                <p>Configuraci√≥n optimizada para <strong>mission-critical systems</strong> con <strong>redundancia de hardware</strong> y <strong>monitoring integrado</strong></p>
            </div>

            <div class="tab-container">
                <button class="tab-button active" onclick="showTab('synthesis-reliability')">S√≠ntesis Confiable</button>
                <button class="tab-button" onclick="showTab('monitoring-stack')">Stack Monitoreo</button>
                <button class="tab-button" onclick="showTab('alerting-escalation')">Alertas y Escalamiento</button>
                <button class="tab-button" onclick="showTab('performance-kpis')">KPIs Rendimiento</button>
            </div>
            
            <div id="synthesis-reliability" class="tab-content active">
                <div class="availability-card">
                    <h3>‚ö° Proceso de S√≠ntesis para Mission-Critical Systems</h3>
                    
                    <div class="steps-grid">
                        <div class="step-card">
                            <div class="step-number">1</div>
                            <h4>üîÑ COMPILACI√ìN REDUNDANTE</h4>
                            <ul>
                                <li>Processing ‚Üí Start Compilation</li>
                                <li>Verificar 0 errores, 0 warnings cr√≠ticos</li>
                                <li>Triple modular redundancy en paths cr√≠ticos</li>
                                <li>Error detection and correction habilitado</li>
                            </ul>
                        </div>
                        
                        <div class="step-card">
                            <div class="step-number">2</div>
                            <h4>üìä AN√ÅLISIS DE CONFIABILIDAD</h4>
                            <ul>
                                <li>Logic Elements: ~30-45 LEs (redundancia)</li>
                                <li>Pines I/O: 20 pines (monitoring incluido)</li>
                                <li>MTBF calculado: >50,000 horas</li>
                                <li>Single point of failure: Eliminado</li>
                            </ul>
                        </div>
                        
                        <div class="step-card">
                            <div class="step-number">3</div>
                            <h4>üå°Ô∏è AN√ÅLISIS RACK ENVIRONMENT</h4>
                            <ul>
                                <li>Temperatura rack: 15¬∞C a 35¬∞C</li>
                                <li>Potencia consumida: <75mW</li>
                                <li>Cooling requirements: Passive OK</li>
                                <li>EMI compliance: Data center grade</li>
                            </ul>
                        </div>
                    </div>

                    <div class="monitoring-card">
                        <h3>üéØ Configuraciones de S√≠ntesis Mission-Critical</h3>
                        <div class="code-block-container">
                            <div class="language-label">TCL - Mission Critical Synthesis</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block"># ================================================
# SCRIPT DE S√çNTESIS PARA SISTEMAS MISSION-CRITICAL
# Optimizado para m√°xima confiabilidad y disponibilidad
# ================================================

# Configuraci√≥n de dispositivo para data center
set_global_assignment -name FAMILY "MAX II"
set_global_assignment -name DEVICE EPM240T100C5
set_global_assignment -name TOP_LEVEL_ENTITY flipflop_d_failover_ha

# Optimizaci√≥n para confiabilidad sobre velocidad
set_global_assignment -name OPTIMIZATION_TECHNIQUE BALANCED
set_global_assignment -name OPTIMIZE_HOLD_TIMING "ALL PATHS"
set_global_assignment -name OPTIMIZE_MULTI_CORNER_TIMING ON
set_global_assignment -name FITTER_EFFORT "STANDARD FIT"

# Error detection and correction para mission-critical
set_global_assignment -name ENABLE_ERROR_DETECTION_ERROR_CORRECTION ON
set_global_assignment -name ENABLE_SINGLE_EVENT_UPSET_MITIGATION ON
set_global_assignment -name CYCLONE_CONFIGURATION_SCHEME "PASSIVE SERIAL"

# Redundancia en paths cr√≠ticos
set_global_assignment -name ALLOW_POWER_UP_DONT_CARE OFF
set_global_assignment -name SYNTH_TIMING_DRIVEN_SYNTHESIS ON
set_global_assignment -name USE_TIMEQUEST_TIMING_ANALYZER ON

# Configuraci√≥n t√©rmica para rack environment
set_global_assignment -name MIN_CORE_JUNCTION_TEMP "0"
set_global_assignment -name MAX_CORE_JUNCTION_TEMP "85"
set_global_assignment -name STRATIX_DEVICE_IO_STANDARD "3.3-V LVTTL"

# Triple modular redundancy para se√±ales cr√≠ticas
set_instance_assignment -name DUPLICATE_REGISTER ON -to primary_server_active
set_instance_assignment -name DUPLICATE_REGISTER ON -to secondary_server_active
set_instance_assignment -name DUPLICATE_REGISTER ON -to failover_in_progress

# Clock redundancy para m√°xima disponibilidad
set_global_assignment -name ENABLE_DEVICE_WIDE_RESET ON
set_global_assignment -name AUTO_GLOBAL_CLOCK_MAX 2
set_global_assignment -name AUTO_GLOBAL_REGISTER_CONTROLS ON

# Timing constraints para sistemas distribuidos
create_clock -name {clk_datacenter} -period 10.000 -waveform { 0.000 5.000 } [get_ports {clk_datacenter}]
create_clock -name {heartbeat_cluster} -period 1000000.000 -waveform { 0.000 500000.000 } [get_ports {heartbeat_cluster}]

# False path constraints para se√±ales as√≠ncronas
set_false_path -from [get_ports reset_emergency] -to [get_registers *]
set_false_path -from [get_ports maintenance_mode] -to [get_registers *]

# Input/Output delays para interfaces de red
set_input_delay -clock [get_clocks clk_datacenter] -max 15.0 [get_ports server_health_primary]
set_input_delay -clock [get_clocks clk_datacenter] -min 2.0 [get_ports server_health_primary]
set_input_delay -clock [get_clocks clk_datacenter] -max 15.0 [get_ports network_connectivity]
set_input_delay -clock [get_clocks clk_datacenter] -min 2.0 [get_ports network_connectivity]

set_output_delay -clock [get_clocks clk_datacenter] -max 20.0 [get_ports primary_server_active]
set_output_delay -clock [get_clocks clk_datacenter] -min 3.0 [get_ports primary_server_active]
set_output_delay -clock [get_clocks clk_datacenter] -max 20.0 [get_ports snmp_trap_trigger]
set_output_delay -clock [get_clocks clk_datacenter] -min 3.0 [get_ports snmp_trap_trigger]

# Maximum delay constraints para SLA compliance
set_max_delay -from [get_ports server_health_primary] -to [get_ports primary_server_active] 100.0
set_max_delay -from [get_ports heartbeat_cluster] -to [get_ports failover_in_progress] 50.0

# Configuraci√≥n de pines no utilizados para seguridad
set_global_assignment -name RESERVE_ALL_UNUSED_PINS_WEAK_PULLUP "AS INPUT TRI-STATED WITH WEAK PULL-UP"

# Report configuration para an√°lisis detallado
set_global_assignment -name TIMEQUEST_REPORT_SCRIPT_INCLUDE_DEFAULT_ANALYSIS ON
set_global_assignment -name TIMEQUEST_DO_REPORT_TIMING ON
set_global_assignment -name TIMEQUEST_DO_CCPP_REMOVAL ON

# Power analysis para rack planning
set_global_assignment -name POWER_PRESET_COOLING_SOLUTION "23 MM HEAT SINK WITH 200 LFPM AIRFLOW"
set_global_assignment -name POWER_BOARD_THERMAL_MODEL "NONE (CONSERVATIVE)"

echo "‚úÖ Configuraci√≥n de s√≠ntesis mission-critical aplicada"
echo "üè¢ Optimizado para data center environment"
echo "üõ°Ô∏è Redundancia y error correction habilitados"</pre>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="monitoring-stack" class="tab-content">
                <div class="monitoring-card">
                    <h3>üìä Integraci√≥n con Stacks de Monitoreo</h3>
                    <p>Configuraci√≥n completa para <strong>observabilidad</strong> y <strong>telemetr√≠a</strong> en tiempo real</p>
                    
                    <div class="datacenter-metrics">
                        <h3>üîß Arquitectura de Monitoreo</h3>
                        <div class="code-block-container">
                            <div class="language-label">YAML - Stack Configuration</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block"># ================================================
# DOCKER COMPOSE PARA STACK DE MONITOREO COMPLETO
# Prometheus + Grafana + AlertManager + ELK Stack
# ================================================

version: '3.8'

services:
  # Prometheus para m√©tricas time-series
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus-ha
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - ./rules/:/etc/prometheus/rules/
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'
      - '--web.enable-admin-api'
    networks:
      - monitoring
    restart: unless-stopped

  # Grafana para visualizaci√≥n
  grafana:
    image: grafana/grafana:latest
    container_name: grafana-ha
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_INSTALL_PLUGINS=grafana-clock-panel,grafana-simple-json-datasource
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
    networks:
      - monitoring
    restart: unless-stopped

  # AlertManager para gesti√≥n de alertas
  alertmanager:
    image: prom/alertmanager:latest
    container_name: alertmanager-ha
    ports:
      - "9093:9093"
    volumes:
      - ./alertmanager.yml:/etc/alertmanager/alertmanager.yml
      - alertmanager_data:/alertmanager
    command:
      - '--config.file=/etc/alertmanager/alertmanager.yml'
      - '--storage.path=/alertmanager'
      - '--web.external-url=http://localhost:9093'
      - '--cluster.listen-address=0.0.0.0:9094'
    networks:
      - monitoring
    restart: unless-stopped

  # Elasticsearch para logs
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.17.0
    container_name: elasticsearch-ha
    environment:
      - node.name=elasticsearch
      - cluster.name=es-docker-cluster
      - discovery.type=single-node
      - bootstrap.memory_lock=true
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - monitoring
    restart: unless-stopped

  # Logstash para procesamiento de logs
  logstash:
    image: docker.elastic.co/logstash/logstash:7.17.0
    container_name: logstash-ha
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline
      - ./logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml
    ports:
      - "5044:5044"
      - "5000:5000/tcp"
      - "5000:5000/udp"
      - "9600:9600"
    environment:
      LS_JAVA_OPTS: "-Xmx256m -Xms256m"
    networks:
      - monitoring
    depends_on:
      - elasticsearch
    restart: unless-stopped

  # Kibana para visualizaci√≥n de logs
  kibana:
    image: docker.elastic.co/kibana/kibana:7.17.0
    container_name: kibana-ha
    ports:
      - "5601:5601"
    environment:
      ELASTICSEARCH_URL: http://elasticsearch:9200
      ELASTICSEARCH_HOSTS: '["http://elasticsearch:9200"]'
    networks:
      - monitoring
    depends_on:
      - elasticsearch
    restart: unless-stopped

  # Node Exporter para m√©tricas del sistema
  node_exporter:
    image: prom/node-exporter:latest
    container_name: node-exporter-ha
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.rootfs=/rootfs'
      - '--path.sysfs=/host/sys'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($|/)'
    networks:
      - monitoring
    restart: unless-stopped

  # FPGA HA Exporter personalizado
  fpga_ha_exporter:
    build: ./fpga_exporter/
    container_name: fpga-ha-exporter
    ports:
      - "8080:8080"
    environment:
      - FPGA_ENDPOINT=http://fpga-controller:8080
      - METRICS_PORT=8080
      - LOG_LEVEL=INFO
    networks:
      - monitoring
    restart: unless-stopped

volumes:
  prometheus_data:
  grafana_data:
  alertmanager_data:
  elasticsearch_data:

networks:
  monitoring:
    driver: bridge

---
# ================================================
# CONFIGURACI√ìN PROMETHEUS PARA FLIP FLOP D HA
# Archivo: prometheus.yml
# ================================================

global:
  scrape_interval: 15s
  evaluation_interval: 15s
  external_labels:
    monitor: 'ha-flipflop-monitor'
    datacenter: 'primary'

rule_files:
  - "rules/flipflop_ha_rules.yml"
  - "rules/infrastructure_rules.yml"

scrape_configs:
  # FPGA HA Controller metrics
  - job_name: 'fpga-ha-controller'
    static_configs:
      - targets: ['fpga_ha_exporter:8080']
    scrape_interval: 5s
    scrape_timeout: 3s
    metrics_path: /metrics
    params:
      format: ['prometheus']

  # System metrics
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node_exporter:9100']
    scrape_interval: 15s

  # Prometheus self-monitoring
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

---
# ================================================
# CONFIGURACI√ìN ALERTMANAGER
# Archivo: alertmanager.yml
# ================================================

global:
  smtp_smarthost: 'smtp.company.com:587'
  smtp_from: 'alerts@company.com'
  smtp_auth_username: 'alerts@company.com'
  smtp_auth_password: 'your_password'

route:
  group_by: ['alertname', 'datacenter', 'service']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'
  routes:
    - match:
        severity: critical
      receiver: 'critical-alerts'
      group_wait: 0s
      repeat_interval: 5m
    - match:
        severity: warning
      receiver: 'warning-alerts'
      repeat_interval: 30m

receivers:
  - name: 'web.hook'
    webhook_configs:
      - url: 'http://localhost:5001/'

  - name: 'critical-alerts'
    email_configs:
      - to: 'oncall@company.com'
        subject: 'üö® CRITICAL: {{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
        body: |
          üö® CRITICAL ALERT DETAILS:
          
          {{ range .Alerts }}
          Alert: {{ .Annotations.summary }}
          Description: {{ .Annotations.description }}
          Service: {{ .Labels.service }}
          Instance: {{ .Labels.instance }}
          Severity: {{ .Labels.severity }}
          
          Runbook: {{ .Annotations.runbook_url }}
          {{ end }}
    
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK'
        channel: '#critical-alerts'
        color: 'danger'
        title: 'üö® Critical Alert'
        text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'

  - name: 'warning-alerts'
    email_configs:
      - to: 'monitoring@company.com'
        subject: '‚ö†Ô∏è WARNING: {{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
    
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK'
        channel: '#monitoring'
        color: 'warning'
        title: '‚ö†Ô∏è Warning Alert'
        text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'

inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'datacenter', 'service']</pre>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="alerting-escalation" class="tab-content">
                <div class="sla-card">
                    <h3>üö® Configuraci√≥n de Alertas y Escalamiento</h3>
                    <p>Sistema de alertas multi-nivel con <strong>escalamiento autom√°tico</strong> y <strong>runbooks integrados</strong></p>
                    
                    <div class="infrastructure-block">
                        <h3>üìû Matriz de Escalamiento</h3>
                        
                        <table class="pin-table">
                            <thead>
                                <tr>
                                    <th>Severidad</th>
                                    <th>Tiempo Respuesta</th>
                                    <th>Escalamiento Nivel 1</th>
                                    <th>Escalamiento Nivel 2</th>
                                    <th>Escalamiento Nivel 3</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>üî¥ Critical</td>
                                    <td>Inmediato</td>
                                    <td>NOC Engineer (5min)</td>
                                    <td>Sr. Engineer (15min)</td>
                                    <td>Engineering Manager (30min)</td>
                                </tr>
                                <tr>
                                    <td>üü° Warning</td>
                                    <td>15 minutos</td>
                                    <td>Monitoring Team</td>
                                    <td>Infrastructure Team (1h)</td>
                                    <td>Team Lead (4h)</td>
                                </tr>
                                <tr>
                                    <td>üîµ Info</td>
                                    <td>1 hora</td>
                                    <td>Email notification</td>
                                    <td>Slack channel</td>
                                    <td>Daily standup</td>
                                </tr>
                                <tr>
                                    <td>üü† Disaster</td>
                                    <td>0 segundos</td>
                                    <td>War Room (immediate)</td>
                                    <td>CTO/VP Engineering (2min)</td>
                                    <td>Executive Team (5min)</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="code-block-container">
                            <div class="language-label">Python - Escalation Logic</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block">#!/usr/bin/env python3
# ================================================
# SISTEMA DE ESCALAMIENTO AUTOM√ÅTICO DE ALERTAS
# Integraci√≥n con PagerDuty, Slack, Email
# ================================================

import time
import json
import requests
import logging
from datetime import datetime, timedelta
from enum import Enum

class AlertSeverity(Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    DISASTER = "disaster"

class EscalationManager:
    def __init__(self, config_file="escalation_config.json"):
        self.config = self.load_config(config_file)
        self.active_alerts = {}
        self.escalation_timers = {}
        self.setup_logging()
    
    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('escalation.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def load_config(self, config_file):
        with open(config_file, 'r') as f:
            return json.load(f)
    
    def process_alert(self, alert):
        """Process incoming alert and determine escalation"""
        alert_id = alert['fingerprint']
        severity = AlertSeverity(alert['labels']['severity'])
        
        self.logger.info(f"üö® Processing alert {alert_id} with severity {severity.value}")
        
        if alert['status'] == 'firing':
            self.handle_firing_alert(alert_id, alert, severity)
        elif alert['status'] == 'resolved':
            self.handle_resolved_alert(alert_id, alert)
    
    def handle_firing_alert(self, alert_id, alert, severity):
        """Handle a firing alert"""
        if alert_id not in self.active_alerts:
            # New alert
            self.active_alerts[alert_id] = {
                'alert': alert,
                'severity': severity,
                'start_time': datetime.now(),
                'escalation_level': 0,
                'last_escalation': datetime.now(),
                'acknowledged': False
            }
            
            # Send initial notification
            self.send_initial_notification(alert_id, alert, severity)
            
            # Start escalation timer
            self.start_escalation_timer(alert_id, severity)
        else:
            # Update existing alert
            self.active_alerts[alert_id]['alert'] = alert
    
    def handle_resolved_alert(self, alert_id, alert):
        """Handle a resolved alert"""
        if alert_id in self.active_alerts:
            duration = datetime.now() - self.active_alerts[alert_id]['start_time']
            
            self.logger.info(f"‚úÖ Alert {alert_id} resolved after {duration}")
            
            # Send resolution notification
            self.send_resolution_notification(alert_id, alert, duration)
            
            # Clean up
            del self.active_alerts[alert_id]
            if alert_id in self.escalation_timers:
                del self.escalation_timers[alert_id]
    
    def send_initial_notification(self, alert_id, alert, severity):
        """Send initial notification based on severity"""
        summary = alert['annotations']['summary']
        description = alert['annotations']['description']
        runbook = alert['annotations'].get('runbook_url', 'No runbook available')
        
        if severity == AlertSeverity.DISASTER:
            self.trigger_war_room(alert_id, alert)
            self.notify_executives(alert_id, alert)
        elif severity == AlertSeverity.CRITICAL:
            self.page_oncall_engineer(alert_id, alert)
            self.send_slack_alert(alert_id, alert, severity)
        elif severity == AlertSeverity.WARNING:
            self.send_email_alert(alert_id, alert)
            self.send_slack_alert(alert_id, alert, severity)
        else:  # INFO
            self.send_email_alert(alert_id, alert)
    
    def start_escalation_timer(self, alert_id, severity):
        """Start escalation timer for alert"""
        escalation_config = self.config['escalation_times'][severity.value]
        
        self.escalation_timers[alert_id] = {
            'next_escalation': datetime.now() + timedelta(minutes=escalation_config['level_1']),
            'level': 1
        }
    
    def check_escalations(self):
        """Check for alerts that need escalation"""
        current_time = datetime.now()
        
        for alert_id, timer in self.escalation_timers.items():
            if alert_id not in self.active_alerts:
                continue
                
            alert_data = self.active_alerts[alert_id]
            
            if not alert_data['acknowledged'] and current_time >= timer['next_escalation']:
                self.escalate_alert(alert_id)
    
    def escalate_alert(self, alert_id):
        """Escalate an alert to the next level"""
        alert_data = self.active_alerts[alert_id]
        severity = alert_data['severity']
        current_level = self.escalation_timers[alert_id]['level']
        
        self.logger.warning(f"‚¨ÜÔ∏è Escalating alert {alert_id} to level {current_level + 1}")
        
        if severity == AlertSeverity.CRITICAL:
            if current_level == 1:
                self.notify_senior_engineer(alert_id, alert_data['alert'])
                next_escalation_minutes = self.config['escalation_times']['critical']['level_2']
            elif current_level == 2:
                self.notify_engineering_manager(alert_id, alert_data['alert'])
                next_escalation_minutes = self.config['escalation_times']['critical']['level_3']
            else:
                self.notify_executives(alert_id, alert_data['alert'])
                next_escalation_minutes = None
        
        elif severity == AlertSeverity.WARNING:
            if current_level == 1:
                self.notify_infrastructure_team(alert_id, alert_data['alert'])
                next_escalation_minutes = self.config['escalation_times']['warning']['level_2']
            elif current_level == 2:
                self.notify_team_lead(alert_id, alert_data['alert'])
                next_escalation_minutes = None
        
        # Update escalation timer
        if next_escalation_minutes:
            self.escalation_timers[alert_id] = {
                'next_escalation': datetime.now() + timedelta(minutes=next_escalation_minutes),
                'level': current_level + 1
            }
        else:
            # Maximum escalation reached
            del self.escalation_timers[alert_id]
    
    def acknowledge_alert(self, alert_id, acknowledger):
        """Acknowledge an alert to stop escalation"""
        if alert_id in self.active_alerts:
            self.active_alerts[alert_id]['acknowledged'] = True
            self.active_alerts[alert_id]['acknowledger'] = acknowledger
            
            self.logger.info(f"‚úã Alert {alert_id} acknowledged by {acknowledger}")
            
            # Stop escalation
            if alert_id in self.escalation_timers:
                del self.escalation_timers[alert_id]
            
            # Notify team of acknowledgment
            self.send_acknowledgment_notification(alert_id, acknowledger)
    
    def trigger_war_room(self, alert_id, alert):
        """Trigger war room for disaster-level alerts"""
        self.logger.critical(f"üî• TRIGGERING WAR ROOM for alert {alert_id}")
        
        # Create war room Slack channel
        war_room_channel = f"war-room-{alert_id[:8]}"
        self.create_slack_channel(war_room_channel)
        
        # Invite key personnel
        key_personnel = self.config['war_room_personnel']
        for person in key_personnel:
            self.invite_to_slack_channel(war_room_channel, person)
        
        # Send urgent notifications
        self.send_sms_alert(self.config['executive_phones'], alert)
    
    def page_oncall_engineer(self, alert_id, alert):
        """Page the on-call engineer via PagerDuty"""
        payload = {
            "routing_key": self.config['pagerduty']['integration_key'],
            "event_action": "trigger",
            "dedup_key": alert_id,
            "payload": {
                "summary": alert['annotations']['summary'],
                "source": alert['labels']['instance'],
                "severity": "critical",
                "custom_details": alert['annotations']
            }
        }
        
        response = requests.post(
            "https://events.pagerduty.com/v2/enqueue",
            json=payload,
            headers={"Content-Type": "application/json"}
        )
        
        if response.status_code == 202:
            self.logger.info(f"üìü PagerDuty alert sent for {alert_id}")
        else:
            self.logger.error(f"‚ùå Failed to send PagerDuty alert: {response.text}")
    
    def send_slack_alert(self, alert_id, alert, severity):
        """Send alert to Slack channel"""
        color_map = {
            AlertSeverity.CRITICAL: "danger",
            AlertSeverity.WARNING: "warning",
            AlertSeverity.INFO: "good"
        }
        
        payload = {
            "channel": self.config['slack']['channel'],
            "attachments": [{
                "color": color_map.get(severity, "warning"),
                "title": f"{severity.value.upper()}: {alert['annotations']['summary']}",
                "text": alert['annotations']['description'],
                "fields": [
                    {"title": "Instance", "value": alert['labels']['instance'], "short": True},
                    {"title": "Service", "value": alert['labels']['service'], "short": True},
                    {"title": "Runbook", "value": alert['annotations'].get('runbook_url', 'N/A'), "short": False}
                ],
                "ts": int(time.time())
            }]
        }
        
        response = requests.post(self.config['slack']['webhook_url'], json=payload)
        
        if response.status_code == 200:
            self.logger.info(f"üí¨ Slack alert sent for {alert_id}")
        else:
            self.logger.error(f"‚ùå Failed to send Slack alert: {response.text}")
    
    def run_escalation_loop(self):
        """Main escalation monitoring loop"""
        self.logger.info("üîÑ Starting escalation monitoring loop...")
        
        while True:
            try:
                self.check_escalations()
                time.sleep(30)  # Check every 30 seconds
                
            except KeyboardInterrupt:
                self.logger.info("üëã Escalation loop stopped by user")
                break
            except Exception as e:
                self.logger.error(f"‚ùå Error in escalation loop: {e}")
                time.sleep(60)

def main():
    """Main entry point for escalation manager"""
    escalation_manager = EscalationManager()
    
    # Start escalation monitoring
    escalation_manager.run_escalation_loop()

if __name__ == "__main__":
    main()</pre>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="performance-kpis" class="tab-content">
                <div class="datacenter-metrics">
                    <h3>üìä KPIs y M√©tricas de Infraestructura</h3>
                    <p>Sistema de medici√≥n continua para optimizaci√≥n del <strong>SLA compliance</strong> y <strong>business value</strong></p>
                    
                    <div class="availability-card">
                        <h3>üéØ Dashboard de KPIs Principales</h3>
                        
                        <div class="steps-grid">
                            <div class="step-card">
                                <div class="step-number">üìà</div>
                                <h4>AVAILABILITY SLA</h4>
                                <p><strong>Target: 99.99%</strong></p>
                                <ul>
                                    <li>Uptime measurement: Real-time</li>
                                    <li>Downtime budget: 4.38 min/month</li>
                                    <li>SLA compliance: Automated tracking</li>
                                </ul>
                            </div>
                            
                            <div class="step-card">
                                <div class="step-number">‚ö°</div>
                                <h4>PERFORMANCE METRICS</h4>
                                <p><strong>Target: <5min MTTR</strong></p>
                                <ul>
                                    <li>Failover time: P95 <2 minutos</li>
                                    <li>Detection time: <30 segundos</li>
                                    <li>Recovery time: <3 minutos</li>
                                </ul>
                            </div>
                            
                            <div class="step-card">
                                <div class="step-number">üõ°Ô∏è</div>
                                <h4>RELIABILITY INDICATORS</h4>
                                <p><strong>Target: >50K hours MTBF</strong></p>
                                <ul>
                                    <li>System health: Continuous monitoring</li>
                                    <li>Error rate: <0.01%</li>
                                    <li>False positives: <1/month</li>
                                </ul>
                            </div>
                            
                            <div class="step-card">
                                <div class="step-number">üí∞</div>
                                <h4>BUSINESS IMPACT</h4>
                                <p><strong>Target: $0 revenue loss</strong></p>
                                <ul>
                                    <li>Downtime cost avoidance: $2M/year</li>
                                    <li>Customer satisfaction: >98%</li>
                                    <li>SLA penalty avoidance: 100%</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="infrastructure-block">
                        <h3>üìã Reporte de Infraestructura Semanal</h3>
                        <div class="code-block-container">
                            <div class="language-label">Executive Report</div>
                            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
                            <pre class="code-block">‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    REPORTE SEMANAL DE INFRAESTRUCTURA HA
    Sistema: FLIP FLOP D Failover Controller
    Per√≠odo: _________________ a _________________
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä EXECUTIVE SUMMARY
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SLA Compliance                                          ‚îÇ
‚îÇ ‚îú‚îÄ Availability Achieved: _____%  (Target: 99.99%)     ‚îÇ
‚îÇ ‚îú‚îÄ Downtime This Period: _____ minutes                 ‚îÇ
‚îÇ ‚îú‚îÄ SLA Budget Remaining: _____ minutes                 ‚îÇ
‚îÇ ‚îî‚îÄ Compliance Status:    ‚úÖ MEETING / ‚ùå BREACH        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üìà PERFORMANCE METRICS
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Failover Performance                                    ‚îÇ
‚îÇ ‚îú‚îÄ Total Failovers:      _____ events                  ‚îÇ
‚îÇ ‚îú‚îÄ Average Failover Time: _____ seconds                ‚îÇ
‚îÇ ‚îú‚îÄ Fastest Failover:     _____ seconds                 ‚îÇ
‚îÇ ‚îú‚îÄ Slowest Failover:     _____ seconds                 ‚îÇ
‚îÇ ‚îî‚îÄ P95 Failover Time:    _____ seconds (Target: <120s) ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ Detection and Recovery                                  ‚îÇ
‚îÇ ‚îú‚îÄ Average Detection Time: _____ seconds               ‚îÇ
‚îÇ ‚îú‚îÄ Average Recovery Time:  _____ seconds               ‚îÇ
‚îÇ ‚îú‚îÄ End-to-End MTTR:      _____ seconds                ‚îÇ
‚îÇ ‚îî‚îÄ MTBF Current:         _____ hours                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üö® INCIDENT SUMMARY
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Incident Categories                                     ‚îÇ
‚îÇ ‚îú‚îÄ Critical Incidents:   _____ (SLA impacting)         ‚îÇ
‚îÇ ‚îú‚îÄ Major Incidents:      _____ (service degradation)   ‚îÇ
‚îÇ ‚îú‚îÄ Minor Incidents:      _____ (no customer impact)    ‚îÇ
‚îÇ ‚îî‚îÄ Total Incidents:      _____                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ Root Cause Analysis                                     ‚îÇ
‚îÇ ‚îú‚îÄ Hardware Failures:    _____ incidents              ‚îÇ
‚îÇ ‚îú‚îÄ Network Issues:       _____ incidents              ‚îÇ
‚îÇ ‚îú‚îÄ Software Bugs:        _____ incidents              ‚îÇ
‚îÇ ‚îú‚îÄ Configuration Errors: _____ incidents              ‚îÇ
‚îÇ ‚îî‚îÄ External Dependencies: _____ incidents              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üìä SYSTEM HEALTH INDICATORS
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Infrastructure Health                                   ‚îÇ
‚îÇ ‚îú‚îÄ Primary Server Health:    ____% average uptime     ‚îÇ
‚îÇ ‚îú‚îÄ Secondary Server Health:  ____% average uptime     ‚îÇ
‚îÇ ‚îú‚îÄ Network Connectivity:     ____% availability       ‚îÇ
‚îÇ ‚îú‚îÄ Storage Cluster Health:   ____% availability       ‚îÇ
‚îÇ ‚îî‚îÄ Load Balancer Health:     ____% availability       ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ Monitoring and Alerting                                ‚îÇ
‚îÇ ‚îú‚îÄ Total Alerts Generated:   _____ alerts             ‚îÇ
‚îÇ ‚îú‚îÄ False Positive Rate:      ____% (Target: <5%)      ‚îÇ
‚îÇ ‚îú‚îÄ Alert Response Time:      _____ minutes average    ‚îÇ
‚îÇ ‚îî‚îÄ Unacknowledged Alerts:    _____ alerts             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üí∞ BUSINESS IMPACT ANALYSIS
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Financial Impact                                        ‚îÇ
‚îÇ ‚îú‚îÄ Revenue at Risk:          $_____ (during downtime)  ‚îÇ
‚îÇ ‚îú‚îÄ Actual Revenue Loss:      $_____ (SLA penalties)    ‚îÇ
‚îÇ ‚îú‚îÄ Cost Avoidance:          $_____ (prevented outages) ‚îÇ
‚îÇ ‚îî‚îÄ ROI This Period:         ____% return on investment ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ Customer Impact                                         ‚îÇ
‚îÇ ‚îú‚îÄ Customers Affected:       _____ customers           ‚îÇ
‚îÇ ‚îú‚îÄ Service Requests:         _____ tickets             ‚îÇ
‚îÇ ‚îú‚îÄ Customer Satisfaction:    ____% (Target: >95%)     ‚îÇ
‚îÇ ‚îî‚îÄ NPS Score:               _____ (Net Promoter Score) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üîÑ CONTINUOUS IMPROVEMENT
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Improvements Implemented                                ‚îÇ
‚îÇ ‚îú‚îÄ Automation Enhancements:  _______________           ‚îÇ
‚îÇ ‚îú‚îÄ Process Improvements:     _______________           ‚îÇ
‚îÇ ‚îú‚îÄ Tool Upgrades:           _______________           ‚îÇ
‚îÇ ‚îî‚îÄ Training Completed:       _______________           ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ Planned Improvements                                    ‚îÇ
‚îÇ ‚îú‚îÄ Next Week:               _______________           ‚îÇ
‚îÇ ‚îú‚îÄ Next Month:              _______________           ‚îÇ
‚îÇ ‚îú‚îÄ Next Quarter:            _______________           ‚îÇ
‚îÇ ‚îî‚îÄ Investment Required:      $_____ budget            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üéØ KEY RECOMMENDATIONS
‚ñ° _________________________________________________
‚ñ° _________________________________________________  
‚ñ° _________________________________________________
‚ñ° _________________________________________________

üìã ACTION ITEMS FOR NEXT PERIOD
‚ñ° High Priority: ___________________________________
‚ñ° Medium Priority: _________________________________
‚ñ° Low Priority: ___________________________________": {
          "defaults": {
            "mappings": [
              {"value": 0, "text": "UNHEALTHY", "color": "red"},
              {"value": 1, "text": "HEALTHY", "color": "green"}
            ]
          }
        }
      },
      {
        "id": 2,
        "title": "Active Server",
        "type": "stat",
        "targets": [
          {
            "expr": "flipflop_primary_server_active",
            "legendFormat": "Primary Active"
          },
          {
            "expr": "flipflop_secondary_server_active", 
            "legendFormat": "Secondary Active"
          }
        ]
      },
      {
        "id": 3,
        "title": "Failover Count (24h)",
        "type": "graph",
        "targets": [
          {
            "expr": "increase(flipflop_failover_count_total[24h])",
            "legendFormat": "Failovers Last 24h"
          }
        ]
      },
      {
        "id": 4,
        "title": "Availability Percentage",
        "type": "gauge",
        "targets": [
          {
            "expr": "flipflop_availability_percentage",
            "legendFormat": "Current Availability %"
          }
        ],
        "fieldConfig